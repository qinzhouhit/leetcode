'''keys: Solutions:Similar: T:S:'''from typing import Listfrom collections import defaultdictclass Solution:    # bitmask    def findRepeatedDnaSequences2(self, s: str) -> List[str]:        L, n = 10, len(s)        if n <= L:            return []        '''        words.add(v) is to avoid adding the substring repeatedly to the         results, and doubleWords.add(v) is make sure substring appears more         than once        '''        words = set()        doubleWords = set()        res = []        to_int = {(ord("A") - ord("A")): 0,                   (ord("C") - ord("A")): 1,                   (ord("G") - ord("A")): 2,                   (ord("T") - ord("A")): 3}                for i in range(n - L + 1):            bitmask = 0            for j in range(i, i + 10):                bitmask <<= 2                bitmask |= to_int[ord(s[j]) - ord("A")]                        if bitmask not in words and bitmask in doubleWords:                res.append(s[i: i + 10])                words.add(bitmask)                        if bitmask not in doubleWords:                doubleWords.add(bitmask)        return res                # slice and rolling hash    def findRepeatedDnaSequences1(self, s: str) -> List[str]:        L, n = 10, len(s)        if n <= L:            return []                # rolling hash parameters: base a        a = 4 # ACGT        aL = pow(a, L)  # a^L                # convert string to array of integers        to_int = {'A': 0, 'C': 1, 'G': 2, 'T': 3}        nums = [to_int.get(s[i]) for i in range(n)]                h = 0        seen, output = set(), set()        # iterate over all sequences of length L        for start in range(n - L + 1):            # compute hash of the current sequence in O(1) time            if start != 0:                h = h * a - nums[start - 1] * aL + nums[start + L - 1]            # compute hash of the first sequence in O(L) time            else:                for i in range(L):                    h = h * a + nums[i] #numeric value of a 4-base number            # update output and hashset of seen sequences            if h in seen:                output.add(s[start:start + L])            seen.add(h)        return output            # naive, T: O((N-L)*L),     def findRepeatedDnaSequences(self, s: str) -> List[str]:        if not s or len(s) <= 10: return []                seen = []        res = set()        for i in range(len(s) - 10 + 1):            sub = s[i: i+10]            if sub in seen:                res.add(sub)            seen.append(sub)        return res                                                                