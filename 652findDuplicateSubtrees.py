'''keys: Solutions:Similar: T:S:'''from typing import Listimport collections# Definition for a binary tree node.class TreeNode:    def __init__(self, val=0, left=None, right=None):        self.val = val        self.left = left        self.right = right              class Solution:        # O(N^2) for S and T    # https://leetcode.com/problems/find-duplicate-subtrees/discuss/106020/Python-easy-understand-solution    def findDuplicateSubtrees(self, root: TreeNode) -> List[TreeNode]:        def trv(root):            if not root: return "null"            struct = "%s,%s,%s" % (str(root.val), trv(root.left), trv(root.right))            nodes[struct].append(root)            return struct                nodes = collections.defaultdict(list)        trv(root)        return [nodes[struct][0] for struct in nodes if len(nodes[struct]) > 1]            # some clear version    def findDuplicateSubtrees2(self, root: TreeNode) -> List[TreeNode]:                def serialize(node, hashmap):            if not node:                return ""            a = serialize(node.left, hashmap)            b = serialize(node.right, hashmap)            tmp = str(node.val) + " " + a + " " + b             hashmap[tmp].append(node)            return tmp                            hashmap = collections.defaultdict(list)        res = []        serialize(root, hashmap)        for group in hashmap.values():            if len(group) > 1:                res.append(group[0])        return res            # serialize the tree    # https://leetcode.com/problems/find-duplicate-subtrees/discuss/106055/C%2B%2B-Java-Clean-Code-with-Explanation    def findDuplicateSubtrees1(self, root: TreeNode) -> List[TreeNode]:                def serialize(node, hashmap):            if not node:                return ""            s = "(" + serialize(node.left, hashmap) + str(node.val) + \                serialize(node.right, hashmap) + ")"            hashmap[s].append(node)            return s                hashmap = collections.defaultdict(list) # k: serialized string, v: list of nodes        duplicates = []        serialize(root, hashmap)        for group in hashmap.values():            if len(group) > 1:                duplicates.append(group[0])        return duplicates                            