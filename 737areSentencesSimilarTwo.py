'''keys: DFS or UF, graphSolutions:Similar: 734T:S:'''from typing import Listimport collectionsclass Solution:    # huahua UF, similar idea, assign some cluster ID    # https://www.youtube.com/watch?v=0rZUi3kZGLI    def areSentencesSimilarTwo3(self, words1: List[str], words2: List[str], pairs: List[List[str]]) -> bool:        pass        # huahua DFS, O(|pairs|+|words|)    # use extra dict to records words and cluster/component ID    def areSentencesSimilarTwo2(self, words1: List[str], words2: List[str], pairs: List[List[str]]) -> bool:        if len(words1) != len(words2):            return False                dict_ = collections.defaultdict(list)        iddict = collections.defaultdict(int)        for w1, w2 in pairs:            dict_[w1].append(w2)            dict_[w2].append(w1)                    # id construct        idx = 0        for pair in pairs:            if pair[0] not in iddict:                idx += 1                self.dfs1(pair[0], idx, iddict, dict_)            if pair[1] not in iddict:                idx += 1                self.dfs1(pair[1], idx, iddict, dict_)                 for i in range(len(words1)):            if words1[i] == words2[i]: continue            id1 = iddict[words1[i]]            id2 = iddict[words2[i]]            if id1 != id2: return False                return True        def dfs1(self, curr, idx, iddict, dict_):         # from curr node, mark all connected nodes as idx        iddict[curr] = idx        for nei in dict_[curr]:            if nei in iddict: continue # nei already assigned id            if self.dfs1(nei, idx, iddict, dict_):                return True        return False        # huahua DFS, O(|pairs|*|words|), see comments below    def areSentencesSimilarTwo1(self, words1: List[str], words2: List[str], pairs: List[List[str]]) -> bool:        if len(words1) != len(words2):            return False                dict_ = collections.defaultdict(list)        for w1, w2 in pairs:            dict_[w1].append(w2)            dict_[w2].append(w1)                for i in range(len(words1)):            visited = set()  # if w1 and w2 are far away, then visiting all pairs            if not self.dfs(words1[i], words2[i], dict_, visited):                return False        return True        def dfs(self, w1, w2, dict_, visited):        if w1 == w2:            return True        visited.add(w1)        for nei in dict_[w1]:            if nei in visited: continue            if self.dfs(nei, w2, dict_, visited):                return True        return False                    # this one, the similarity relationship is transitive    # in 734, it is not transitive    # similar: connected as a component    # check are the pairs, each pair must be in the same component     # T: O(|pairs|+|words|)    # S: O(|pairs|): number of edges in the graph    def areSentencesSimilarTwo(self, words1: List[str], words2: List[str], pairs: List[List[str]]) -> bool:        if len(words1) != len(words2):            return False                dict_ = collections.defaultdict(list)        for w1, w2 in pairs:            dict_[w1].append(w2)            dict_[w2].append(w1)        for w1, w2 in zip(words1, words2):            stack = [w1]            visited = {w1}            while stack:                word = stack.pop()                if word == w2: break                for nei in dict_[word]:                    if nei not in visited:                        visited.add(nei)                        stack.append(nei)            else:                return False                return True                                        sol = Solution()print (sol.areSentencesSimilarTwo1(["great","acting","skills"],["fine","painting","talent"],[["great","fine"],["drama","acting"],["skills","talent"]]))