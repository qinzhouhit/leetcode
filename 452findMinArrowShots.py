'''keys: Solutions:Similar:T:S:'''from typing import List'''Greedy problems usually look like "Find minimum number of something to do something" or "Find maximum number of something to fit in some conditions", and typically propose an unsorted input.'''class Solution:    # T: O(NlogN); S: O(N) (Timsort)    def findMinArrowShots(self, points: List[List[int]]) -> int:        if not points:            return 0                # sort by x_end        points.sort(key = lambda x : x[1])                arrows = 1        first_end = points[0][1]        for x_start, x_end in points:            # if the current balloon starts after the end of another one,            # one needs one more arrow            # the key is that we only update first_end when overlap            # that means when not overlap, the first_end remains            if first_end < x_start:                arrows += 1                first_end = x_end                return arrows