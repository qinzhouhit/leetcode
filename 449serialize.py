'''keys: directly using the method from 297 is fineSolutions:Similar: 297, 428T:S:'''from typing import Listfrom collections import deque# Definition for a binary tree node.class TreeNode:    def __init__(self, x):        self.val = x        self.left = None        self.right = Noneclass Codec:        # use this one, more of my style    # preorder    def serialize1(self, root: TreeNode) -> str:        """Encodes a tree to a single string.        """        def transform(node):            # we don't need # for None            if node:                vals.append(str(node.val))                transform(node.left)                transform(node.right)                    vals = []        transform(root)        return " ".join(vals)        def deserialize(self, data: str) -> TreeNode:        """        Decodes your encoded data to tree.        """        def helper(lower = float('-inf'), upper = float('inf')):            # use upper and lower boundaries to check whether we should add null            # we peek the data first, not pop            if not queue or queue[0] < lower or queue[0] > upper:                return None                        val = queue.popleft()            root = TreeNode(val)            root.left = helper(lower, val)            root.right = helper(val, upper)            # print (root)            return root                            queue = deque([int(x) for x in data.split(' ') if x])        return helper()                ##### previous version    # for optimal deserialization better to choose the     # postorder traversal because member/global/static     # variables are not allowed here. ??? preorder is fine, see 297    # O(N) for S and T    # we don't have to store "#" for None nodes, since we can use BST features    # i.e., root larger than left and smaller than right     def serialize(self, root: TreeNode) -> str:        """        Encodes a tree to a single string.        """        if not root: return ""                def postorder(node):            return postorder(root.left) + postorder(root.right)\            + [root.val] if root else []        # return ' '.join(map(str, postorder(root)))        return " ".join(str(v) for v in postorder(root))        def serialize1(self, root: TreeNode) -> str:        """        Encodes a tree to a single string.        """        def transform(node):            if node:                vals.append(str(node.val))                transform(node.left)                transform(node.right)        vals = []        transform(root)        return " ".join(vals)        def deserialize(self, data: str) -> TreeNode:        """        Decodes your encoded data to tree.        """        def helper(lower = float('-inf'), upper = float('inf')):            # use upper and lower boundaries to check whether we should add null            if not data or data[-1] < lower or data[-1] > upper:                return None                        val = data.pop()            root = TreeNode(val)            root.right = helper(val, upper) # right node must have value no smaller than parent            root.left = helper(lower, val)            return root                            data = [int(x) for x in data.split(' ') if x]        return helper()                # Your Codec object will be instantiated and called as such:# codec = Codec()# codec.deserialize(codec.serialize(root))