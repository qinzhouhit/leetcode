'''keys: Solutions:Similar: T:S:'''from typing import Listclass CharInString:    def __init__(self, val, pos):        self.val = val        self.pos = posclass Solution:    # follow up, three different types of brackets, i.e., â€˜[],{},()'    # https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/discuss/441109/java-FOLLOW-UP%3A-we-asked-to-check-if-string-valid-with-many-different-types-of-parenthesis    def minRemoveToMakeValid2(self, s: str) -> str:        n = len(s)        closeMap = {")": "(", "]": "[", "}": "{"}        openSet = set(["(", "[", "{"])        stack = []        toRemove = set()        for i, cur in enumerate(s):            cur_obj = CharInString(cur, i)            if cur_obj.val in closeMap: # the letters are skipped                if not stack:                    toRemove.add(i)                elif stack[0].val != closeMap[cur_obj.val]:                    toRemove.add(i)                else: # pop the open side and cancel out the pairs                    stack.pop()            elif cur_obj.val in openSet:                stack.append(cur_obj)        if stack: # still chars in stack            while stack: # .pos can track the location of the                 toRemove.add(stack.pop().pos)        string_builder = []        for i, c in enumerate(s):            if i not in toRemove:                string_builder.append(c)        return "".join(string_builder)    # with one type of parenthesis    def minRemoveToMakeValid3(self, s: str) -> str:        toRemove = set()        stack = []        for i, c in enumerate(s):            if c == ")":                if not stack:                    toRemove.add(i)                elif s[stack[0]] != "(":                    toRemove.add(i)                else:                    stack.pop()            elif c == "(":                stack.append(i)                    if stack:            while stack:                toRemove.add(stack.pop())                builder = []        for i, c in enumerate(s):            if i not in toRemove:                builder.append(c)        return "".join(builder)    # O(n) for S and T, n as the length of the input string    def minRemoveToMakeValid(self, s: str) -> str:        indexes_to_remove = set()        stack = []        for i, c in enumerate(s):            if c not in "()": # letter                continue            if c == "(":                stack.append(i)            elif not stack:                indexes_to_remove.add(i)            else:                stack.pop()        indexes_to_remove = indexes_to_remove.union(set(stack))        ''' instead of using union, we can:        if stack:            while stack:                toRemove.add(stack.pop())        '''        string_builder = []        for i, c in enumerate(s):            if i not in indexes_to_remove:                string_builder.append(c)        return "".join(string_builder)        def minRemoveToMakeValid1(self, s: str) -> str:        def delete_invalid_closing(string, open_symbol, close_symbol):            sb = []            balance = 0            for c in string:                if c == open_symbol:                    balance += 1                if c == close_symbol:                    if balance == 0:                        continue                    balance -= 1                sb.append(c)            return "".join(sb)            # Note that s[::-1] gets the reverse of s.        s = delete_invalid_closing(s, "(", ")")        print(s)        s = delete_invalid_closing(s[::-1], ")", "(")        print(s)        return s[::-1]    sol = Solution()  # print (sol.minRemoveToMakeValid1("lee(t(c)o)de)"))# print (sol.minRemoveToMakeValid2("lee(t(c]ode)"))print (sol.minRemoveToMakeValid2("a)b(c)d"))