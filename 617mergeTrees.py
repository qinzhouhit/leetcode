'''keys: Solutions:Similar: T:S:'''from typing import List# Definition for a binary tree node.class TreeNode:    def __init__(self, val=0, left=None, right=None):        self.val = val        self.left = left        self.right = right                class Solution:    # iteration    def mergeTrees1(self, t1: TreeNode, t2: TreeNode) -> TreeNode:        if not t1: return t2        stack = []        stack.append((t1, t2))        while stack:            n1, n2 = stack.pop()            if not n1 or not n2:                continue            n1.val += n2.val            if not n1.left:                n1.left = n2.left            else:                stack.append((n1.left, n2.left))            if not n1.right:                n1.right = n2.right            else:                stack.append((n1.right, n2.right))        return t1            # clever corner case dealing    def mergeTrees2(self, t1: TreeNode, t2: TreeNode) -> TreeNode:        if not t1 and not t2: return None        ans = TreeNode((t1.val if t1 else 0) + (t2.val if t2 else 0))        ans.left = self.mergeTrees(t1 and t1.left, t2 and t2.left)        ans.right = self.mergeTrees(t1 and t1.right, t2 and t2.right)        return ans                                # recursion    # O(m) for S and T, m as number of nodes    def mergeTrees(self, t1: TreeNode, t2: TreeNode) -> TreeNode:        # if not t1 and not t2: return None        if not t1:            return t2        if not t2:            return t1        t1.val += t2.val        t1.left = self.mergeTrees(t1.left, t2.left)        t1.right = self.mergeTrees(t1.right, t2.right)        return t1