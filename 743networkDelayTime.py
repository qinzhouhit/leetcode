'''keys: Solutions:Similar: T:S:'''from typing import Listimport collectionsfrom collections import heapqclass Solution:    # Dijkstra heap version    # T: O(N^2 + E), E as length of times, O(ElogE) for heap version    # S: O(N + E)    def networkDelayTime1(self, times, N, K):        graph = collections.defaultdict(list)        for u, v, w in times:            graph[u].append((v, w))        pq = [(0, K)]        dist = {}        while pq:            d, node = heapq.heappop(pq)            if node in dist: continue            dist[node] = d            for nei, d2 in graph[node]:                if nei not in dist:                    heapq.heappush(pq, (d+d2, nei))        return max(dist.values()) if len(dist) == N else -1            def networkDelayTime(self, times: List[List[int]], N: int, K: int) -> int:        graph = collections.defaultdict(list)                for u, v, w in times:            graph[u].append((w, v))                    dist = {node: float("inf") for node in range(1, N+1)}        def dfs(node, elapsed):            if elapsed >= dist[node]:                return            dist[node] = elapsed            for time, nei in sorted(graph[node]):                dfs(nei, elapsed+time)                dfs(K, 0)        ans = max(dist.values())        return ans if ans < float("inf") else -1                