'''keys: Solutions:Similar: T:S:'''from typing import Listimport collectionsfrom collections import heapqclass Solution:    # Dijkstra heap version    # T: O(N^2 + E), E as length of times, O(ElogE) for heap version    # S: O(N + E)    def networkDelayTime1(self, times, N, K):        graph = collections.defaultdict(list)        for u, v, w in times:            graph[u].append((v, w))        pq = [(0, K)] # 1st: time for K to cur node, 2nd: the cur node        dist = {}        while pq:            d, node = heapq.heappop(pq)            if node in dist:                 # because we use heap, pop the min delay, if seen it twice                # the second time it must be a longer delay                continue             dist[node] = d            for nei, d2 in graph[node]:                if nei not in dist:                    heapq.heappush(pq, (d+d2, nei))        return max(dist.values()) if len(dist) == N else -1    # basic dijkstra    def networkDelayTime1(self, times, N, K):        graph = collections.defaultdict(list)        for u, v, w in times:            graph[u].append((v, w))        # dist meaning the dist from K to cur node        dist = {node: float('inf') for node in range(1, N+1)}        seen = [False] * (N+1)        dist[K] = 0        while True:            cand_node = -1            cand_dist = float('inf')            for i in range(1, N+1):                if not seen[i] and dist[i] < cand_dist:                    cand_node = i                    cand_dist = dist[i]                                if cand_node < 0: # after all nodes, the node is not reachable                break # break the while loop            seen[cand_node] = True            for nei, d in graph[cand_node]:                dist[nei] = min(dist[nei], dist[cand_node] + d)        ans = max(dist.values())        return ans if ans < float('inf') else -1            def networkDelayTime(self, times: List[List[int]], N: int, K: int) -> int:        graph = collections.defaultdict(list)                for u, v, w in times:            graph[u].append((w, v))                    dist = {node: float("inf") for node in range(1, N+1)}        def dfs(node, elapsed):            if elapsed >= dist[node]:                return            dist[node] = elapsed            for time, nei in sorted(graph[node]):                dfs(nei, elapsed+time)                dfs(K, 0)        ans = max(dist.values())        return ans if ans < float("inf") else -1                