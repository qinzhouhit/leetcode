'''keys: Solutions:Similar: T:S:'''from typing import List'''say the the difference is d between a and b, such as d = b - a(b is on the right of a). you want d is multiple of k, so you just need d % k = 0. Because d = b - a, so d % k = 0 = (b - a) %k. so (b-a)%k=0 equal b%k - a%k = 0, then b%k = a%k. Comparing other hashtable based problem, you need check b-k whether in the hashtable. '''class Solution:    # O(n) for T and O(min(n,k)) for S, i.e., hashmap    def checkSubarraySum1(self, nums: List[int], k: int) -> bool:        sum_ = 0        hashmap = {0:-1}        for i in range(len(nums)):            sum_ += nums[i]            if k != 0:                sum_ = sum_ % k            if sum_ in hashmap:                if i - hashmap[sum_] > 1:                    return True            else:                hashmap[sum_] = i        return False        def checkSubarraySum2(self, nums, k):        if k == 0:            return any(nums[i] == 0 and nums[i + 1] == 0 for i in range(len(nums) - 1))        mods, cum_sum_mod_k = {0: -1}, 0        for i, n in enumerate(nums):            cum_sum_mod_k = (cum_sum_mod_k + n) % k            if cum_sum_mod_k in mods and i - mods[cum_sum_mod_k] > 1:                return True            if cum_sum_mod_k not in mods:                mods[cum_sum_mod_k] = i        return False        # O(n^2) for T and O(n) for S    def checkSubarraySum(self, nums: List[int], k: int) -> bool:        sum_list = [0]*len(nums)        sum_list[0] = nums[0]        for i in range(1, len(nums)):            sum_list[i] = sum_list[i-1] + nums[i]        for start in range(len(nums)-1):            for end in range(start+1, len(nums)):                summ = sum_list[end] - sum_list[start] + nums[start]                if (summ == k) or (k != 0 and summ % k == 0):                    return True        return False