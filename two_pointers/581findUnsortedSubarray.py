'''keys: Solutions:Similar: T:S:'''from typing import Listclass Solution:    # educative.io    def findUnsortedSubarray4(self, nums: List[int]) -> int:        l, r = 0, len(nums)-1        while l < len(nums) - 1 and nums[l] <= nums[l+1]:            l += 1        if l == len(nums)-1:            return 0        while r > 0 and nums[r-1] <= nums[r]:            r -= 1 # we don't do r == 0 check since it's the same as l==len(nums)-1        maxx, minn = -float("inf"), float("inf")        for i in range(l, r+1):            maxx = max(maxx, nums[i])            minn = min(minn, nums[i])        # include more numbers if the "outer" nums are larger then min or smaller than max        while l > 0 and nums[l-1] > minn:            l -= 1        while r < len(nums)-1 and nums[r+1] < maxx:            r += 1        return r - l + 1    # O(1) for S    def findUnsortedSubarray3(self, nums: List[int]) -> int:        def find_min_max(l, r):            local_minimum = float('inf')            local_maximum = float('-inf')            for i in range(l, r+1):                if i == len(nums):                    break                local_minimum = min(local_minimum, nums[i])                local_maximum = max(local_maximum, nums[i])            return local_minimum, local_maximum                        if len(nums) < 2: return 0                l, r = 0, len(nums) - 1        while l < len(nums) - 1 and nums[l] <= nums[l + 1]:            l += 1        while r > 0 and nums[r] >= nums[r -1]:            r -= 1        if l > r:            return 0                    tempMin, tempMax = find_min_max(l, r+1)                while l > 0 and tempMin < nums[l-1]:            l -= 1        while r < len(nums) - 1 and tempMax > nums[r+1]:            r += 1                    return r - l + 1        # O(n) for S an T    # https://leetcode.com/problems/shortest-unsorted-continuous-subarray/discuss/103067/Python-O(N)-with-O(1)-space-complexity.-No-sorting    def findUnsortedSubarray2(self, nums: List[int]) -> int:        if len(nums) < 2: return 0                l, r = 0, len(nums) - 1        while l < len(nums) - 1 and nums[l] <= nums[l + 1]:            l += 1        while r > 0 and nums[r] >= nums[r -1]:            r -= 1        if l > r:            return 0                    temp = nums[l:r+1]        tempMin = min(temp)        tempMax = max(temp)                while l > 0 and tempMin < nums[l-1]:            l -= 1        while r < len(nums) - 1 and tempMax > nums[r+1]:            r += 1        return r - l + 1            # sorting; O(nlogn) and O(1)    def findUnsortedSubarray1(self, nums: List[int]) -> int:        tmp = sorted(nums)        l, r = len(nums), 0        for i in range(len(nums)):            if tmp[i] != nums[i]:                l = min(i, l)                r = max(i, l)        return (r - l + 1) if r - l > 0 else 0        # my sorting; O(nlogn) and O(n)    def findUnsortedSubarray(self, nums: List[int]) -> int:        tmp = sorted(nums)        l = []        for i in range(len(nums)):            if tmp[i] != nums[i]:                l.append(i)        return (l[-1] - l[0] + 1) if l else 0        