'''keys: Solutions:Similar: T:S:'''from typing import Listfrom collections import itertools# Definition for a binary tree node.class TreeNode:    def __init__(self, val=0, left=None, right=None):        self.val = val        self.left = left        self.right = right                class Solution:    # official, O(T1 + T2),  T1 , T2 are the lengths of the given trees.    def leafSimilar1(self, root1: TreeNode, root2: TreeNode) -> bool:        def dfs(node):            if node:                if not node.left and not node.right:                    yield node.val                yield from dfs(node.left)                yield from dfs(node.right)        return list(dfs(root1)) == list(dfs(root2))        def leafSimilar2(self, root1: TreeNode, root2: TreeNode) -> bool:        def dfs(node):            if not node: return            if not node.left and not node.right: yield node.val            for i in dfs(node.left): yield i            for i in dfs(node.right): yield i        return all(a == b for a, b in itertools.izip_longest(dfs(root1), dfs(root2)))        # self made    def leafSimilar(self, root1: TreeNode, root2: TreeNode) -> bool:        if not root1 and not root2:            return True                def find(root):            if not root:                return []                        stack = [root]            res = []            while stack:                node = stack.pop()                if node:                    if node.left:                        stack.append(node.left)                    if node.right:                        stack.append(node.right)                    elif not node.left and not node.right:                        res.append(node.val)            return res                res1 = find(root1)        res2 = find(root2)        print (res1, res2)        return res1 == res2