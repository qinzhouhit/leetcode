'''keys: union find, the redundant edge will form a loopSolutions:Similar: T:S:'''from typing import Listimport collectionsclass Solution:            # UF, T: O(nlogn) = O(n)    def findRedundantConnection1(self, edges: List[List[int]]) -> List[int]:        parents = [0] * (len(edges)+1) # 0 means no parent        sizes = [1] * (len(edges)+1) # size of node itself is 1                for edge in edges:            u = edge[0]; v = edge[1]            if not parents[u]: parents[u] = u            if not parents[v]: parents[v] = v            pu = self.find(u, parents) # find root node of u            pv = self.find(v, parents)                        if pu == pv: return edge # in the same tree            # union, merge smaller set pv to the larger set pu            # if pv > pu, make pv the smaller one            if sizes[pv] > sizes[pu]:                pv, pu = pu, pv                        parents[pv] = pu # pv's parent is pu            sizes[pu] += sizes[pv]        return {}                def find(self, node, parents):        # notice that here only one while loop instead of two        while parents[node] != node: # node is not the root node now            parents[node] = parents[parents[node]] # make grandpa as parent            node = parents[node] # go to the parent node        return node # if parents[node] == node        # DFS, T: O(n^2)    def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:        graph = collections.defaultdict(list)        for edge in edges:            u = edge[0]            v = edge[1]                        visited = set()            if self.hasPath(u, v, graph, visited):                # there is a path from u to v, adding the u-v edge will make                # a loop, so that's the redundant one                return edge                         graph[u].append(v)            graph[v].append(u)        return {} # not found            def hasPath(self, curr, goal, graph, visited):        if curr == goal: return True        visited.add(curr)        if curr not in graph or goal not in graph:            return False # u, v not in graph        for nei in graph[curr]: # neighbors            if nei in visited:                continue            if self.hasPath(nei, goal, graph, visited):                return True        return False                        