'''keys: Solutions:Similar: T:S:'''from typing import List# Definition for a binary tree node.class TreeNode:    def __init__(self, val=0, left=None, right=None):        self.val = val        self.left = left        self.right = right        class Solution:    # O(n) for S and T. S: recursive stack    def boundaryOfBinaryTree1(self, root):        def dfs_leftmost(node):            # pre-order for left boundary            if not node or not node.left and not node.right:                return            boundary.append(node.val)            if node.left:                dfs_leftmost(node.left)            else:                dfs_leftmost(node.right)        def dfs_leaves(node):            #  in-order for bottom boundary             if not node:                return            dfs_leaves(node.left) # this line can also be put before the last line            if node != root and not node.left and not node.right:                boundary.append(node.val)            dfs_leaves(node.right)        def dfs_rightmost(node):            # post-order (but going right node first) for right boundary            if not node or not node.left and not node.right:                return            if node.right:                dfs_rightmost(node.right)            else:                dfs_rightmost(node.left)            boundary.append(node.val)        if not root:            return []        boundary = [root.val]        dfs_leftmost(root.left)        dfs_leaves(root)        dfs_rightmost(root.right)        return boundary            # straight forward; extra space    def boundaryOfBinaryTree(self, root: TreeNode) -> List[int]:        if not root: return []                left_bd_nodes = [root]        cur = root.left        while cur:            left_bd_nodes.append(cur)            cur = cur.left if cur.left else cur.right                right_bd_nodes = [root]        cur = root.right        while cur:            right_bd_nodes.append(cur)            cur = cur.right if cur.right else cur.left                leaf_nodes = []        stack = [root]        while stack:            node = stack.pop()            if node.right:                stack.append(node.right)            if node.left:                stack.append(node.left)            if not node.right and not node.left:                leaf_nodes.append(node)                res = []        seen = set()        def visit(node):            if node not in seen:                seen.add(node)                res.append(node.val)                for node in left_bd_nodes:            visit(node)        for node in leaf_nodes:            visit(node)        for node in right_bd_nodes[::-1]:            visit(node)                return res                                                                                                                                                