'''keys: Solutions:Similar:T:S:'''from typing import Listimport collections'''The recursive approach is more elegant, but is considered inferior to the iterative version in some programming languages, such as Python. This is because the space used by run-time stacks vary between programming languages.'''class Solution:    # 4, 5: we only check: 1) nodes number and edege number    # 2) fully connected or not    # O(N) for S and T, since E = N - 1    def validTree4(self, n: int, edges: List[List[int]]) -> bool:            if len(edges) != n - 1: return False                # Create an adjacency list.        adj_list = [[] for _ in range(n)]        for A, B in edges:            adj_list[A].append(B)            adj_list[B].append(A)                # We still need a seen set to prevent our code from infinite        # looping if there *is* cycles (and on the trivial cycles!)        seen = {0}        stack = [0]                while stack:            node = stack.pop()            for neighbour in adj_list[node]:                if neighbour in seen:                    continue                seen.add(neighbour)                stack.append(neighbour)                return len(seen) == n            # 1, 2, 3 avoids the trivial loops    # iterative DFS, O(N+E) for nodes and edges, both S and T    def validTree3(self, n: int, edges: List[List[int]]) -> bool:        # thinking about triangle, 3 nodes and 3 edges -> not tree        if len(edges) != n - 1:            return False                adj_list = [[] for _ in range(n)]        for a, b in edges:            adj_list[a].append(b)            adj_list[b].append(a)                    parent = {0: -1} # k: node, v: its parent        stack = [0] # the 1st node                while stack:            node = stack.pop()            for nei in adj_list[node]:                # we don't want to revisit the same node                if nei == parent[node]:                    continue                # spot a cycle                if nei in parent:                    return False                parent[nei] = node                stack.append(nei)        # if fully connected, then every node must have been seen        return len(parent) == n            # recursive DFS    def validTree2(self, n: int, edges: List[List[int]]) -> bool:        if len(edges) != n - 1: return False                adj_list = [[] for _ in range(n)]        for A, B in edges:            adj_list[A].append(B)            adj_list[B].append(A)                seen = set()                def dfs(node, parent):            if node in seen: return;            seen.add(node)            for neighbour in adj_list[node]:                if neighbour == parent:                    continue                if neighbour in seen:                    return False                result = dfs(neighbour, node)                if not result: return False            return True                # We return true iff no cycles were detected,        # AND the entire graph has been reached.        return dfs(0, -1) and len(seen) == n        # iterative BFS    def validTree1(self, n: int, edges: List[List[int]]) -> bool:        if len(edges) != n - 1: return False                adj_list = [[] for _ in range(n)]        for A, B in edges:            adj_list[A].append(B)            adj_list[B].append(A)                parent = {0: -1}        queue = collections.deque([0])                while queue:            node = queue.popleft()            for neighbour in adj_list[node]:                if neighbour == parent[node]:                    continue                if neighbour in parent:                    return False                parent[neighbour] = node                queue.append(neighbour)                return len(parent) == n    