'''keys: Solutions:Similar: T:S:'''from typing import Listclass Solution:    '''    The smaller numbers on the right of a number are exactly those that jump     from its right to its left during a stable sort. So I do mergesort with     added tracking of those right-to-left jumps.    https://leetcode.com/problems/count-of-smaller-numbers-after-self/discuss/76584/Mergesort-solution    '''    def countSmaller1(self, nums: List[int]) -> List[int]:                def sort(indexes):            half = len(indexes) // 2            if half:                left, right = sort(indexes[:half]), sort(indexes[half:])                for i in range(len(indexes))[::-1]:                    if not right or left and nums[left[-1]] > nums[right[-1]]:                        smaller[left[-1]] += len(right)                        indexes[i] = left.pop()                    else:                        indexes[i] = right.pop()            return indexes                smaller = [0] * len(nums)        sort(list(range(len(nums))))        return smaller            # original merge sort    def merge_sort(self, values):         if len(values)>1:             m = len(values)//2            left = values[:m]             right = values[m:]             left = self.merge_sort(left)             right = self.merge_sort(right)                   values =[]                   while len(left)>0 and len(right)>0:                 if left[0]<right[0]:                     values.append(left[0])                     left.pop(0)                 else:                     values.append(right[0])                     right.pop(0)                   for i in left:                 values.append(i)             for i in right:                 values.append(i)                               return values                 # TLE    def countSmaller(self, nums: List[int]) -> List[int]:        if not nums: return []                res = [0] * len(nums)        for i in range(len(nums)-1, -1, -1):            num = nums[i]            ct = 0            if i+1 < len(nums):                for j in range(i+1, len(nums)):                    if nums[j] < num:                        ct += 1            res[i] = ct        return res        sol = Solution()print (sol.merge_sort([38, 27, 43, 3, 9, 82, 10]))