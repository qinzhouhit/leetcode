'''keys: Solutions:Similar: T:S:'''from typing import Listclass Solution:	# https://leetcode.com/problems/find-k-closest-elements/discuss/106426/JavaC%2B%2BPython-Binary-Search-O(log(N-K)-%2B-K)    # T: O(log(n-k)), logn for the binary search, k for shrinking the range to k    # S: O(k) for the res    # Note that, you SHOULD NOT compare the absolute value of abs(x - A[mid])     # and abs(A[mid + k] - x).    # It fails at cases like A = [1,1,2,2,2,2,2,3,3], x = 3, k = 3    def findClosestElements(self, arr: List[int], k: int, x: int) -> List[int]:    	# assume A[mid] ~ A[mid + k] is sliding window        left, right = 0, len(arr) - k - 1 # since we need a window as length k        while left <= right:            mid = (left + right) // 2            # -------A[mid]------------------x---A[mid + k]----------            # -------A[mid]---------------------A[mid + k]----x------            # need to move the window right            if x - arr[mid] > arr[mid + k] - x:                left = mid + 1            # -------x----A[mid]-----------------A[mid + k]----------            # -------A[mid]----x-----------------A[mid + k]----------            # these cases, move the window left            else:                right = mid - 1        return arr[left:left + k]    # educative.io heap version    # T: O(logN+K*logK). We need O(logN)O(logN) for Binary Search and O(K*logK)    # to insert the numbers in the MinHeap and sort the output    # S: O(K)    def findClosestElements2(self, arr: List[int], k: int, x: int) -> List[int]:        def binary_search(arr, target):            l, r = 0, len(arr) - 1            while l <= r:                mid = l + (r - l) // 2                if arr[mid] == target:                    return mid                if arr[mid] < target:                    l = mid + 1                else:                    r = mid - 1            # if l > 0: # would run faster with it            #     return l - 1            return l        idx = binary_search(arr, x)        l, r = idx - k, idx + k        l = max(l, 0)        r = min(r, len(arr)-1)        minHeap = []        for i in range(l, r+1):            heappush(minHeap, (abs(arr[i]-x), arr[i]))        res = []        for _ in range(k):            res.append(heappop(minHeap)[1])        res.sort()        return res    # binary search + two pointers    # T: O(logN + K), logN for binary and K for two pointers    # S: O(1)    def findClosestElements1(self, arr: List[int], k: int, x: int) -> List[int]:        def binary_search(arr, target):            l, r = 0, len(arr) - 1            while l <= r:                mid = l + (r - l) // 2                if arr[mid] == target:                    return mid                if arr[mid] < target:                    l = mid + 1                else:                    r = mid - 1            # if l > 0: # ???            #     return l - 1            return r # return the right one will do        res = deque()        idx = binary_search(arr, x)         lptr, rptr = idx, idx + 1        n = len(arr)        for _ in range(k): # we can't simply expand to left and right equally by k//2            if lptr >= 0 and rptr < n:                diff1 = abs(x - arr[lptr])                diff2 = abs(x - arr[rptr])                if diff1 <= diff2:                    res.appendleft(arr[lptr])                    lptr -= 1                else:                    res.append(arr[rptr])                    rptr += 1            elif lptr >= 0: # rptr already out of range                res.appendleft(arr[lptr])                lptr -= 1            elif rptr < n: # lptr already out of range                res.append(arr[rptr])                rptr += 1        return res