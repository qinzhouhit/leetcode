'''keys: Solutions:Similar:T:S:'''from typing import List# Definition for a binary tree node.class TreeNode:    def __init__(self, val=0, left=None, right=None):        self.val = val        self.left = left        self.right = rightclass Solution:    # O(N) for S and T    def sumOfLeftLeaves1(self, root: TreeNode) -> int:        if root is None:            return 0        def process_subtree(node, is_left):            # Base case: This is a leaf node.            if node.left is None and node.right is None:                return node.val if is_left else 0                        # Recursive case: We need to add and return the results of the             # left and right subtrees.            total = 0            if node.left:                total += process_subtree(node.left, True)            if node.right:                total += process_subtree(node.right, False)            return total                # Call the recursive function on the root node to start the process.        # We need to be careful of the case that the root is empty.        return process_subtree(root, False)        # T: O(N), S: O(logN) if it is balanced tree    def sumOfLeftLeaves(self, root: TreeNode) -> int:        if root is None:             return 0        def is_leaf(node):            return node and not node.left and not node.right        stack = [root]        total = 0        while stack:            sub_root = stack.pop()            # Check if the left node is a leaf node.            if is_leaf(sub_root.left):                total += sub_root.left.val            # If the right node exists, put it on the stack.            if sub_root.right is not None:                stack.append(sub_root.right)            # If the left node exists, put it on the stack.            if sub_root.left is not None:                stack.append(sub_root.left)        return total            