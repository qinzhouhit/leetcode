'''keys: Solutions:Similar: T:S:'''from typing import Listclass Solution:            # bitwise trie    def findMaximumXOR1(self, nums: List[int]) -> int:        # Compute length L of max number in a binary representation        L = len(bin(max(nums))) - 2        # zero left-padding to ensure L bits for each number        nums = [[(x >> i) & 1 for i in range(L)][::-1] for x in nums]                max_xor = 0        trie = {}        for num in nums:            node = trie            xor_node = trie            curr_xor = 0            for bit in num:                # insert new number in trie                if not bit in node:                    node[bit] = {}                node = node[bit]                                # to compute max xor of that new number                 # with all previously inserted                toggled_bit = 1 - bit                if toggled_bit in xor_node:                    curr_xor = (curr_xor << 1) | 1                    xor_node = xor_node[toggled_bit]                else:                    curr_xor = curr_xor << 1                    xor_node = xor_node[bit]                                max_xor = max(max_xor, curr_xor)        return max_xor                    # bitwise prefixes in Hashset; idea: making leftmost bits (prefix) max    # T: O(N), S: O(1)    def findMaximumXOR(self, nums: List[int]) -> int:        # length of max number in a binary representation        L = len(bin(max(nums))) - 2 # "0b1010", 2 for "0b"        max_xor = 0        # from the leftmost bit Lâˆ’1 to the rightmost bit 0        for i in range(L)[::-1]:            # go to the next bit by the left shift            max_xor <<= 1            # set 1 in the smallest bit            curr_xor = max_xor | 1            # compute all existing prefixes             # of length (L - i) in binary representation            prefixes = {num >> i for num in nums}            # Update max_xor, if two of these prefixes could result in curr_xor.            # Check if p1^p2 == curr_xor, i.e. p1 == curr_xor^p2            max_xor |= any(curr_xor^p in prefixes for p in prefixes)                            return max_xor