'''keys: split into two subsetsSolutions:Similar: 518T:S:'''from typing import Listclass Solution:    # space optimize    # T: O(len(nums) * (sum(nums)//2)), one dimension     # S: O(sum(nums)//2)    def canPartition1(self, nums: List[int]) -> bool:        sum_ = sum(nums)        if sum_ % 2: return False                sum_ //= 2 # our target        dp = [False] * (sum_ + 1)                     dp[0] = True                for num in nums:            for i in range(sum_, 0, -1): # the trick to make it one dimension                if i >= num:                    dp[i] = dp[i] or dp[i-num]        # print (dp)        return dp[-1]            # the educative.io version    # dp[i][j], obtain sum j by using first i vals [0:i]    def canPartition4(self, nums: List[int]) -> bool:        s = sum(nums)        if s % 2: return False        s //= 2        n = len(nums)        dp = [[False] * (s+1) for _ in range(n)]        # populate the s=0 col, always true, i.e., using 0 number        for i in range(n):            dp[i][0] = True        # using one number, i.e., dp[0][xxx]        for j in range(1, s+1):            dp[0][j] = nums[0] == j        for i in range(1, n):            for j in range(1, s+1):                # get sum as j without the number at idx i                if dp[i-1][j]:                    dp[i][j] = dp[i-1][j]                elif j >= nums[i]: # find a subset to get the remaining sum                    dp[i][j] = dp[i-1][j-nums[i]]         return dp[n-1][s] # bottom-right corner    '''    Let us assume dp[i][j] means whether the specific sum j can be obtained     from the first i numbers. If we can pick such a series of numbers from     0-i whose sum is j, dp[i][j] is true, otherwise it is false.    '''    # bottom up dp    # S and T: O(len(nums) * (sum(nums)//2))    def canPartition(self, nums: List[int]) -> bool:        sum_ = sum(nums)        if sum_ % 2: return False # odd, impossible to split into even subsums        sum_ //= 2 # subset sum        # padding one row and one column, i.e., no number and 0 index        dp = [[False] * (sum_ + 1) for _ in range(len(nums)+1)] # with padding                    dp[0][0] = True                for i in range(1, len(nums)+1):            for j in range(1, sum_ + 1): # remaining sum                dp[i][j] = dp[i-1][j] # without including i-th number                if nums[i-1] <= j: # including i-th number at cur step                    dp[i][j] = dp[i-1][j] or dp[i-1][j-nums[i-1]]        return dp[len(nums)][sum_]    # top-down, i.e., using memo    def canPartition3(self, nums: List[int]) -> bool:        s = sum(nums)        if s % 2: return False         s //= sum(nums)        # memo[i][j]: the first i numbers to accumulative sum of j        memo = [[-1] * (s+1) for _ in range(len(nums))]        return True if self.helper3(memo, nums, s, 0) == 1 else False    def helper3(self, memo, nums, s, curIdx):        if s == 0: # s is the remaining sum            return 1        if s < 0 or curIdx >= len(nums):            return 0        if memo[curIdx][s] != -1:            return memo[curIdx][s]        res = self.helper3(memo, nums, s-nums[curIdx], curIdx+1) or\            self.helper3(memo, nums, s, curIdx+1)        memo[curIdx][s] = res        return memo[curIdx][s]            # recursion, i.e., dfs, TLE    # T: O(2^n), n representing the total number    # S: O(n) for the recursion stack    def canPartition2(self, nums: List[int]) -> bool:        s = sum(nums)        if s % 2 != 0:            return False         return self.helper(nums, s//2, 0)    def helper(self, nums, sum, curIdx): # sum is like the remanining sum        if sum == 0:            return True        n = len(nums)        if curIdx >= n or sum < 0:             return False        res = self.helper(nums, sum-nums[curIdx], curIdx+1) or \        self.helper(nums, sum, curIdx+1) # include/ exclude the number        return res                