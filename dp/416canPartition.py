'''keys: split into two subsetsSolutions:Similar: 518T:S:'''from typing import Listclass Solution:    # space optimize    # T: O(len(nums) * (sum(nums)//2)), one dimension     # S: O(sum(nums)//2)    def canPartition1(self, nums: List[int]) -> bool:        sum_ = sum(nums)        if sum_ % 2: return False                sum_ //= 2 # our target        dp = [False] * (sum_ + 1)                     dp[0] = True                for num in nums:            for i in range(sum_, 0, -1): # the trick to make it one dimension                if i >= num:                    dp[i] = dp[i] or dp[i-num]        # print (dp)        return dp[-1]                    '''    Let us assume dp[i][j] means whether the specific sum j can be gotten     from the first i numbers. If we can pick such a series of numbers from     0-i whose sum is j, dp[i][j] is true, otherwise it is false.    '''    # bottom up dp    # S and T: O(len(nums) * (sum(nums)//2))    def canPartition(self, nums: List[int]) -> bool:        sum_ = sum(nums)        if sum_ % 2: return False # odd, impossible to split into even subsums        sum_ //= 2 # subset sum        # padding one row and one column, i.e., no number and 0 index        dp = [[False] * (sum_ + 1) for _ in range(len(nums)+1)]                # for i in range(1, len(nums)):         #     dp[i][0] = True # using numbers to get sum 0, always True, i.e., dump them        # for j in range(1, sum_ + 1):        #     dp[0][j] = False # using no number, all False                    dp[0][0] = True                for i in range(1, len(nums)+1):            for j in range(1, sum_ + 1): # remaining sum                dp[i][j] = dp[i-1][j] # without including i-th number                if nums[i-1] <= j: # including i-th number at cur step                    dp[i][j] = dp[i-1][j] or dp[i-1][j-nums[i-1]]        return dp[len(nums)][sum_]    # top-down, i.e., using memo    def canPartition3(self, nums: List[int]) -> bool:        s = sum(nums)        if s % 2: return False         s //= sum(nums)        memo = [[-1] * (s+1) for _ in range(len(nums))]        return True if self.helper3(memo, nums, s, 0) == 1 else False    def helper3(self, memo, nums, s, curIdx):        if s == 0:            return 1        if s < 0 or curIdx >= len(nums):            return 0        if memo[curIdx][s] != -1:            return memo[curIdx][s]        res = self.helper3(memo, nums, s-nums[curIdx], curIdx+1) or\            self.helper3(memo, nums, s, curIdx+1)        memo[curIdx][s] = res        return memo[curIdx][s]            # recursion, i.e., dfs    # T: O(2^n), n representing the total number    # S: O(n) for the recursion stack    def canPartition2(self, nums: List[int]) -> bool:        s = sum(nums)        if s % 2 != 0:            return False         return self.helper(nums, s//2, 0)    def helper(self, nums, sum, curIdx): # sum is like the remanining sum        if sum == 0:            return True        n = len(nums)        if curIdx >= n or sum < 0:             return False        res = self.helper(nums, sum-nums[curIdx], curIdx+1) or \        self.helper(nums, sum, curIdx+1) # include/ exclude the number        return res                