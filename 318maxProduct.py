'''keys: Solutions:Similar: T:S:'''from typing import Listfrom collections import defaultdictclass Solution:    # optimise on the number of comparisons    # T: O(L), i.e., O(N^2 + L) where N < 2^26    def maxProduct2(self, words: List[str]) -> int:        hashmap = defaultdict(int)        bit_number = lambda ch : ord(ch) - ord('a')                for word in words:            bitmask = 0            for ch in word:                # add bit number bit_number in bitmask                bitmask |= 1 << bit_number(ch)            # there could be different words with the same bitmask            # ex. ab and aabb            # default value of defaultdict(int): 0            hashmap[bitmask] = max(hashmap[bitmask], len(word))                max_prod = 0        for x in hashmap:            for y in hashmap:                if x & y == 0:                    max_prod = max(max_prod, hashmap[x] * hashmap[y])        return max_prod            # bitmasks    # T: O(N^2 + L), N as the number of words, L as the total length of all words    # S: O(N) for two arrays of N elements    def maxProduct1(self, words: List[str]) -> int:        n = len(words)        masks = [0] * n        lens = [0] * n        bit_number = lambda ch : ord(ch) - ord('a')                for i in range(n):            lens[i] = len(words[i]) # track the lengths of words            bitmask = 0            for ch in words[i]:                # add bit number bit_number in bitmask                bitmask |= 1 << bit_number(ch)            masks[i] = bitmask                                max_val = 0        for i in range(n):            for j in range(i + 1, n):                if masks[i] & masks[j] == 0: # no overlapping                    max_val = max(max_val, lens[i] * lens[j])        return max_val                    # self-made naive, T: O(l1*l2)    def maxProduct(self, words: List[str]) -> int:        if not words: return 0                res = []        n = len(words)        for i in range(n):            for j in range(i+1, n):                w1, w2 = words[i], words[j]                if self.distinguish(w1, w2):                    res.append(len(w1)*len(w2))        return max(res) if res else 0                    def distinguish(self, w1, w2):        for c in w1:            if c not in w2:                continue            else:                return False        return True