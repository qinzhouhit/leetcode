'''keys: Solutions:Similar: T:S:'''from typing import Listfrom itertools import permutationsclass Solution:        # permutation via backtracking, i.e., hand-made permutation    def largestTimeFromDigits2(self, arr: List[int]) -> str:        max_time = -1        def build_time(permutation):            nonlocal max_time            h, i, j, k = permutation            hour = h*10 + i            minute = j*10 + k            if hour < 24 and minute < 60:                max_time = max(max_time, hour * 60 + minute)        def swap(array, i, j):            if i != j:                array[i], array[j] = array[j], array[i]        def permutate(array, start):            if start == len(array):                build_time(array)                return            for index in range(start, len(array)):                swap(array, index, start)                # repeat the permutation with the original array mutated                permutate(array, start+1)                swap(array, index, start)        permutate(arr, 0)        if max_time == -1:            return ""        else:            return "{:02d}:{:02d}".format(max_time // 60, max_time % 60)                    # official: enumerate the permutations    def largestTimeFromDigits1(self, arr: List[int]) -> str:        max_time = -1        # enumerate all possibilities, with the permutation() func        #  the time complexity to generate the permutations would be O(1)        for h, i, j, k in permutations(arr):            hour = h*10 + i            minute = j*10 + k            if hour < 24 and minute < 60:                max_time = max(max_time, hour * 60 + minute)                if max_time == -1:            return ""        else:            return "{:02d}:{:02d}".format(max_time // 60, max_time % 60)                # self-made, T: O(1)    def isTime(self, str_com):        if str_com[0] > 2:             return False        if str_com[0] == 2 and str_com[1] > 3:            return False        if str_com[2] > 5:            return False        return True                    def largestTimeFromDigits(self, arr: List[int]) -> str:        combos = []        if not arr: return res                combos = permutations(arr)        cands = []        for combo in combos:            if self.isTime(combo):                cands.append(combo)        if not cands: return ""        strs = []        for cand in cands:            strs.append("".join([str(v) for v in cand]))        max_ = max(strs)        return max_[:2] + ":" + max_[2:]                