'''keys: Solutions:Similar: 159T:S:'''from typing import Listimport collectionsclass Solution:    # use ordereddict    # Time complexity: O(N) since all operations with ordered     # S: O(k) since we need to keep k+1 elements in orderedDict    # dictionary : insert/get/delete/popitem (put/containsKey/remove)     # are done in a constant time.            # if character is already in the hashmap -            # delete it, so that after insert it becomes            # the rightmost element in the hashmap            # since order is preserved for insertion of ordereddict            '''            hashmap[s[r]] = r without del:            if not using del, then for "abaccc, k=2", it would be             OrderedDict([('a', 0)]) 0            OrderedDict([('a', 0), ('b', 1)]) 1            OrderedDict([('a', 2), ('b', 1)]) 2 # here "a" shoule be rightmost,             but orderedDict will remain the order, making popitem popping "a"            OrderedDict([('a', 2), ('b', 1), ('c', 3)]) 3            OrderedDict([('b', 1), ('c', 4)]) 3            OrderedDict([('b', 1), ('c', 5)]) 3            '''                        '''            using del:            OrderedDict([('a', 0)]) res: 1            OrderedDict([('a', 0), ('b', 1)]) 2            OrderedDict([('b', 1), ('a', 2)]) 3            OrderedDict([('b', 1), ('a', 2), ('c', 3)]) 3            OrderedDict([('a', 2), ('c', 4)]) 3            OrderedDict([('a', 2), ('c', 5)]) 4            '''            # c = s[r]            # if s[r] in hashmap:            #     del hashmap[c]            # hashmap[c] = r            # r += 1    def lengthOfLongestSubstringKDistinct1(self, s: str, k: int) -> int:                n = len(s)        if n == 0 or k == 0:            return 0        res = 1 # at least we can have 1 char        l, r = 0, 0        hashmap = collections.OrderedDict()                while r < n: # r <= n-1            if s[r] in hashmap:                del hashmap[s[r]]            hashmap[s[r]] = r            r += 1                        if len(hashmap) == k + 1:                # FIFO if last = False; LIFO if last = True                # pop: key, value pair                _, del_idx = hashmap.popitem(last = False)                l = del_idx + 1            res = max(res, r - l) # note that we dont need to add 1 since we have r+=1 or l=idx+1        return res                    # self-made, ST same as the below hashmap+sliding window one    def lengthOfLongestSubstringKDistinct2(self, s: str, k: int) -> int:        if not s:            return 0        if k <= 0:            return 0        cur = deque()        res = float("-inf")        l = 0        for r, c in enumerate(s):            cur.append(c)            while len(set(cur)) > k:                cur.popleft()                l += 1            res = max(res, r-l+1)        return res            # use hashmap    # same as 159 except change the length threshold    # T: O(N) if k distinct chars and O(Nk) if N distinct chars    # S: O(k) for the hashmap    def lengthOfLongestSubstringKDistinct(self, s: str, k: int) -> int:        res = 0        l, r = 0, 0        n = len(s)        hashmap = collections.defaultdict(int)        while r < n:            if len(hashmap) < k + 1:                hashmap[s[r]] = r                r += 1                        if len(hashmap) == k + 1:                del_idx = min(hashmap.values()) # delete the leftmost idx                del hashmap[s[del_idx]]                l = del_idx + 1                        res = max(res, r - l)        return res                sol = Solution()sol.lengthOfLongestSubstringKDistinct1("abaccc", 2)