'''keys: sliding windowSolutions: use cumulative product, until we have the product > kthen we divide the product by the leftmost idx then increase the left idxSimilar: 560, 974T:S:'''from typing import Listclass Solution:    # O(N) for T and O(1) for S    def numSubarrayProductLessThanK(self, nums: List[int], k: int) -> int:        if k <= 1: return 0        pro = 1        res = l = 0        for r, val in enumerate(nums):            pro *= val            # dont need l < len(nums)            while pro >= k and l < len(nums):                 pro /= nums[l]                l += 1            res += r - l + 1 # the number of subarrays for nums[l:r+1]        return res                            # advanced: return all the corresponding subarrays    # T: O(N) for sliding, O(N^2) for creating subarrays    # S: O(N^2) # number of contiguous subarrays, n + (n-1) + ... + 1    from collections import deque    def find_subarrays(self, arr, target):        res = []        pro = 1 # product        l = 0        for r, val in enumerate(arr):            pro *= val            # shrinking, moving left pointer            while pro >= target and l < len(arr):                pro /= arr[l]                l += 1            # to avoid duplicate, we expend from arr[r] to left            # e.g., [2, 5, 3, 10], k =30            # if we expand from left, when num = 2, we have [2]             # when num = 5, we have [2], [2, 5], then [2] is repeated            # expand from right: when num = 2, we have [2]            # when num = 5, we have [5, 2], [5], no duplicates            tmp = deque()            for i in range(r, l-1, -1):                tmp.appendleft(arr[i])                res.append(list(tmp))        return res            