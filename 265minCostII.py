'''keys: Solutions:Similar: 256T:S:'''from typing import Listfrom functools import lru_cacheclass Solution:    # https://leetcode.com/problems/paint-house-ii/solution/    # T: O(nk); S: O(1), using the original space    def minCostII2(self, costs: List[List[int]]) -> int:        n = len(costs)        if n == 0: return 0        k = len(costs[0])            for house in range(1, n):            # Find the colors with the minimum cost and second to minimum            # in the previous row.            min_color = second_min_color = None            for color in range(k):                cost = costs[house - 1][color]                if min_color is None or cost < costs[house - 1][min_color]:                    second_min_color = min_color                    min_color = color                elif second_min_color is None or \                        cost < costs[house - 1][second_min_color]:                    second_min_color = color            # And now update the costs for the current row.            for color in range(k):                if color == min_color:                    costs[house][color] += costs[house - 1][second_min_color]                else:                    costs[house][color] += costs[house - 1][min_color]            #The answer will now be the minimum of the last row.        return min(costs[-1])            # recursion with memo, slow    # T: O(n*k^2); n*k calls for helper, within helper, k loops    # S: O(n*k) for memo    def minCostII(self, costs: List[List[int]]) -> int:        # Start by defining n and k to make the following code cleaner.        n = len(costs)        if n == 0: return 0 # No houses is a valid test case!        k = len(costs[0]) # number of colors        # lru as memo        @lru_cache(maxsize=None)        def helper(house_num, color):            # Base case, reaching last house            if house_num == n - 1:                  return costs[house_num][color]            # Recursive case.            cost = float("inf")            for next_color in range(k):                if next_color == color:                    continue # Can't paint adjacent houses the same color!                cost = min(cost, helper(house_num + 1, next_color))            return costs[house_num][color] + cost        # Consider all options for painting house 0 and find the minimum.        cost = float("inf")        for color in range(k):            cost = min(cost, helper(0, color))        return cost