'''keys: Solutions:Similar: 159T:S:'''from typing import Listimport collectionsclass Solution:    # use ordereddict    # Time complexity :  O ( N ) O(N) since all operations with ordered     # dictionary : insert/get/delete/popitem (put/containsKey/remove)     # are done in a constant time.    def lengthOfLongestSubstringKDistinct1(self, s: str, k: int) -> int:        res = 0        n = len(s)        if n == 0 or k == 0:            return 0                l, r = 0, 0        hashmap = collections.OrderedDict()                while r < n:            # if character is already in the hashmap -            # delete it, so that after insert it becomes            # the rightmost element in the hashmap            # since order is preserved for insertion of ordereddict            '''            if not using del, then for "abaccc, k=2", it would be             OrderedDict([('a', 0)]) 0            OrderedDict([('a', 0), ('b', 1)]) 1            OrderedDict([('a', 2), ('b', 1)]) 2 # here "a" shoule be rightmost,             but orderedDict will remain the order, making popitem popping "a"            OrderedDict([('a', 2), ('b', 1), ('c', 3)]) 3            OrderedDict([('b', 1), ('c', 4)]) 3            OrderedDict([('b', 1), ('c', 5)]) 3            '''                        '''            using del:            OrderedDict([('a', 0)]) res: 1            OrderedDict([('a', 0), ('b', 1)]) 2            OrderedDict([('b', 1), ('a', 2)]) 3            OrderedDict([('b', 1), ('a', 2), ('c', 3)]) 3            OrderedDict([('a', 2), ('c', 4)]) 3            OrderedDict([('a', 2), ('c', 5)]) 4            '''            # c = s[r]            # if s[r] in hashmap:            #     del hashmap[c]            # hashmap[c] = r            # r += 1            if len(hashmap) < k + 1:                hashmap[s[r]] = r                r += 1                        if len(hashmap) == k + 1:                # FIFO if last = False; LIFO if last = True                # pop: key, value pair                _, del_idx = hashmap.popitem(last = False)                l = del_idx + 1            res = max(res, r - l)        return res                                            # use hashmap    # same as 159 except change the length threshold    def lengthOfLongestSubstringKDistinct(self, s: str, k: int) -> int:        res = 0        l, r = 0, 0        n = len(s)        hashmap = collections.defaultdict(int)        while r < n:            if len(hashmap) < k + 1:                hashmap[s[r]] = r                r += 1                        if len(hashmap) == k + 1:                del_idx = min(hashmap.values())                del hashmap[s[del_idx]]                l = del_idx + 1                        res = max(res, r - l)        return res                sol = Solution()sol.lengthOfLongestSubstringKDistinct1("abaccc", 2)