'''keys: Solutions:Similar: T:S:'''from typing import List# Definition for a binary tree node.class TreeNode:    def __init__(self, val=0, left=None, right=None):        self.val = val        self.left = left        self.right = rightclass Solution:    # linear time    def recoverTree(self, root: TreeNode) -> None:        """        Do not return anything, modify root in-place instead.        """                def inorder(r: TreeNode) -> List[int]:            return inorder(r.left) + [r.val] + inorder(r.right) if r else []                def find_two_swapped(nums: List[int]) -> (int, int):            n = len(nums)            x = y = -1            for i in range(n - 1):                if nums[i + 1] < nums[i]:                    y = nums[i + 1]                    # first swap occurence                    if x == -1:                             x = nums[i]                    # second swap occurence                    else:                                   break            return x, y                def recover(r: TreeNode, count: int):            if r:                if r.val == x or r.val == y:                    if r.val == x:                        r.val = y                     else:                        r.val = x                    count -= 1                    if count == 0:                        return                      recover(r.left, count)                recover(r.right, count)                nums = inorder(root)        x, y = find_two_swapped(nums)        recover(root, 2)                        