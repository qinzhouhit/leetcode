'''keys:Solutions:Similar:T:S:'''from typing import List# https://leetcode.com/problems/minimum-swaps-to-make-sequences-increasing/discuss/119879/C%2B%2BJavaPython-DP-O(N)-Solution'''swap[i]: min swaps to make A[0: i] and B[0: i] increasing if we SWAP A[i] and B[i]not_swap[i]: min swaps to make A[0: i] and B[0: i] increasing if we DO NOT swap A[i] and B[i]'''class Solution:    # O(1) for S    def minSwap1(self, A: List[int], B: List[int]) -> int:        N = len(A)        not_swap, swap = 0, 1        for i in range(1, N):            not_swap2 = swap2 = N             if A[i - 1] < A[i] and B[i - 1] < B[i]:                swap2 = swap + 1                not_swap2 = not_swap            if A[i - 1] < B[i] and B[i - 1] < A[i]:                swap2 = min(swap2, not_swap + 1)                not_swap2 = min(not_swap2, swap)            swap, not_swap = swap2, not_swap2        return min(swap, not_swap)            # O(N) for S and T    def minSwap(self, A: List[int], B: List[int]) -> int:        N = len(A)        not_swap, swap = [N] * N, [N] * N        not_swap[0], swap[0] = 0, 1        for i in range(1, N):            if A[i - 1] < A[i] and B[i - 1] < B[i]:                swap[i] = swap[i - 1] + 1                not_swap[i] = not_swap[i - 1]            if A[i - 1] < B[i] and B[i - 1] < A[i]: # two ways                # keep (i-1)-th and swap at i-th, so not_swap[i - 1] + 1                swap[i] = min(swap[i], not_swap[i - 1] + 1)                # keep i-th or swap at (i-1)-th                not_swap[i] = min(not_swap[i], swap[i - 1])        return min(swap[-1], not_swap[-1])            # O(2^n) for DFS    # https://www.youtube.com/watch?v=__yxFFRQAl8