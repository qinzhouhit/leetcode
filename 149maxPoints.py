'''keys: Solutions:Similar: T:S:'''from typing import Listimport sysimport mathimport collectionsclass Solution:    # https://leetcode.com/problems/max-points-on-a-line/discuss/47268/Two-concise-python-solutions.    # O(n^2)    def maxPoints1(self, points: List[List[int]]) -> int:        if len(points) <= 2: return len(points)        d = collections.defaultdict(int) # (x,y) : count        result = 0        for i in range(len(points)):            d.clear()            overlap = 0            curmax = 0            for j in range(i+1, len(points)):                dx = points[j][0] - points[i][0]                dy = points[j][1] - points[i][1]                if dx == 0 and dy == 0: # vertical or horizontal lines                    overlap += 1                    continue                gcd = self.getGcd(dx, dy)                dx //= gcd                dy //= gcd                d[(dx,dy)] += 1                curmax = max(curmax, d[(dx,dy)])            result = max(result, curmax + overlap + 1)        return result    # A note to anyone struggling to use math.gcd(): the built-in function     # doesn't preserve negative numbers. The self.gcd() function posted     # above does.    def getGcd(self, a, b):        if b == 0: return a        return self.getGcd(b, a%b)        def maxPoints(self, points: List[List[int]]) -> int:        def max_points_on_a_line_containing_point_i(i):            """            Compute the max number of points            for a line containing point i.            """            def slope_coprime(x1, y1, x2, y2):                """ to avoid the precision issue with the float/double number,                    using a pair of co-prime numbers to represent the slope.                """                delta_x, delta_y = x1 - x2, y1 - y2                if delta_x == 0:    # vertical line                    return (0, 0)                elif delta_y == 0:  # horizontal line                    return (sys.maxsize, sys.maxsize)                elif delta_x < 0:                    # to have a consistent representation,                    #   keep the delta_x always positive.                    delta_x, delta_y = - delta_x, - delta_y                gcd = math.gcd(delta_x, delta_y)                slope = (delta_x / gcd, delta_y / gcd)                return slope                        def add_line(i, j, count, duplicates):                    """                    Add a line passing through i and j points.                    Update max number of points on a line containing point i.                    Update a number of duplicates of i point.                    """                    # rewrite points as coordinates                    x1 = points[i][0]                    y1 = points[i][1]                    x2 = points[j][0]                    y2 = points[j][1]                    # add a duplicate point                    if x1 == x2 and y1 == y2:                          duplicates += 1                    # add a horisontal line : y = const                    elif y1 == y2:                        nonlocal horizontal_lines                        horizontal_lines += 1                        count = max(horizontal_lines, count)                    # add a line : x = slope * y + c                    # only slope is needed for a hash-map                    # since we always start from the same point                    else:                        slope = slope_coprime(x1, y1, x2, y2)                        lines[slope] = lines.get(slope, 1) + 1                        count = max(lines[slope], count)                    return count, duplicates                        # init lines passing through point i            lines, horizontal_lines = {}, 1            # One starts with just one point on a line : point i.            count = 1            # There is no duplicates of a point i so far.            duplicates = 0            # Compute lines passing through point i (fixed)            # and point j (interation).            # Update in a loop the number of points on a line            # and the number of duplicates of point i.            for j in range(i + 1, n):                count, duplicates = add_line(i, j, count, duplicates)            return count + duplicates                    # If the number of points is less than 3        # they are all on the same line.        n = len(points)        if n < 3:            return n                max_count = 1        # Compute in a loop a max number of points         # on a line containing point i.        for i in range(n - 1):            max_count = max(max_points_on_a_line_containing_point_i(i), max_count)        return max_count