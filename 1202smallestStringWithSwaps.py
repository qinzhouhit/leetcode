'''keys: Solutions: https://www.youtube.com/watch?v=qosJ4632QAgSimilar: T:S:'''from typing import Listimport collectionsclass UF:    def __init__(self, n):         self.p = list(range(n))            def union(self, x, y): # no rank version        self.p[self.find(x)] = self.find(y)            def find(self, x):        if x != self.p[x]:             self.p[x] = self.find(self.p[x])        return self.p[x]class Solution:    # union find, AC    def smallestStringWithSwaps1(self, s: str, pairs: List[List[int]]) -> str:        uf, res, m = UF(len(s)), [], collections.defaultdict(list)        # build connected components where each component is a list of         # indices that can be exchanged with any of them        for x, y in pairs:             uf.union(x,y)        for i in range(len(s)):             m[uf.find(i)].append(s[i])        # Then we build a sorted list of characters for every connected        # component.        for comp_id in m.keys():             m[comp_id].sort(reverse=True)        # we iterate through all the indices, and for each index we         # locate its component id and find the sorted list         # correspondng to that component and grab the next lowest         # character from that list.        for i in range(len(s)):             res.append(m[uf.find(i)].pop())        return ''.join(res)                # DFS, TLE    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:        graph = collections.defaultdict(list)        for pair in pairs:            graph[pair[0]].append(pair[1])            graph[pair[1]].append(pair[0])                res = list(s)        seen = set()        self.idx = []        self.tmp = ''        # find connected components        def dfs(cur):            if cur in seen:                return            seen.add(cur)            self.idx.append(cur)            self.tmp += s[cur]            for nxt in graph[cur]:                dfs(nxt)                for i in range(len(s)):            if i in seen:                continue            self.idx = []            self.tmp = ''            dfs(i)            tmp_list = list(self.tmp)            tmp_list.sort()            self.tmp = "".join(tmp_list)            # self.tmp.sort()            self.idx.sort()            for k in range(len(self.idx)):                res[self.idx[k]] = list(self.tmp)[k]        return "".join(res)                                        