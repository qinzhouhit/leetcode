'''keys: transform matrix into graph, then find connected componentsSolutions:Similar: T:S:'''from typing import Listclass Solution:    # in-place dfs    def findCircleNum1(self, M: List[List[int]]) -> int:        if not M: return 0        n = len(M)        res = 0        for i in range(n):            if not M[i][i]: continue # use M[i][i] as indcator for visited            res += 1            self.dfs1(M, i, n)        return res        def dfs1(self, M, cur, n):        for i in range(n): # notice that i could be qual to cur            if not M[cur][i]: # likely the values of the 2D-array are not                # continuous in the buffer, then visiting memory may be required                # thus leading to extra time                continue # cur and i are not friends            # the case that cur == i will also be gone            M[cur][i] = M[i][cur] = 0 # cur and i are friends            self.dfs1(M, i, n)                # extra space dfs; O(n^2) for T and O(n) for S    # each person has no friend: O(n^2)    def findCircleNum(self, M: List[List[int]]) -> int:        if not M: return 0        n = len(M)        # 1D array can be read in one piece into buffer        # then no need to visit memory, more efficient than 2D array        visited = [0] * n # 0 means still here, 1 means visited/gone        res = 0        for i in range(n):            if visited[i]:                continue            self.dfs(M, i, n, visited)            res += 1        return res        def dfs(self, M, curr, n, visited):        if visited[curr]:            return        visited[curr] = 1         # visit all friends/ neighbors        for i in range(n):            # M[curr][i] == 1 => curr and i are friends            if M[curr][i] and not visited[i]:                self.dfs(M, i, n, visited)                