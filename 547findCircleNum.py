'''keys: transform matrix into graph, then find connected componentsSolutions:Similar: T:S:'''from typing import Listclass Solution:    # in-place dfs    def findCircleNum1(self, M: List[List[int]]) -> int:        if not M: return 0        n = len(M)        res = 0        for i in range(n):            if not M[i][i]:                 continue # use M[i][i] as indcator for visited            res += 1            self.dfs1(M, i, n) # mark all the connecte provinces        return res        def dfs1(self, M, cur, n):        for i in range(n): # notice that i could be qual to cur            if not M[cur][i]: # likely the values of the 2D-array are not                # continuous in the buffer, then visiting memory may be required                # thus leading to extra time                continue # cur and i are not friends            # the case that cur == i will also be gone            M[cur][i] = M[i][cur] = 0 # cur and i are friends            self.dfs1(M, i, n)                # extra space dfs; O(n^2) for T and O(n) for S    # each person has no friend: O(n^2)    def findCircleNum(self, M: List[List[int]]) -> int:        if not M: return 0        n = len(M)        # 1D array can be read in one piece into buffer        # then no need to visit memory, more efficient than 2D array        visited = [0] * n # 0 means still here, 1 means visited/gone        res = 0        for i in range(n):            if visited[i]:                continue            self.dfs(M, i, n, visited)            res += 1        return res        def dfs(self, M, curr, n, visited):        if visited[curr]:            return        visited[curr] = 1         # visit all friends/ neighbors        for i in range(n):            # M[curr][i] == 1 => curr and i are friends            if M[curr][i] and not visited[i]:                self.dfs(M, i, n, visited)                ##### self-made DSU'''I think for Union-Find approach, the complexity could be O(n^2) if path compression is used. Union-Find complexity with path compression is O(m), which m is operations (either union/find); in this case, since m[i][j] = m[j][i], the union operation is at most n*(n-1)/2, therefore it is O(n^2)'''class DSU:    def __init__(self):        self.id = {}        self.size = {}        self.ct = 0        def add(self, val):        self.id[val] = val        self.size[val] = 1        self.ct += 1        def find(self, val):        while self.id[val] != val:            self.id[val] = self.id[self.id[val]]            val = self.id[val]        return val        def union(self, a, b):        ra, rb = self.find(a), self.find(b)        if ra == rb:            return        if self.size[a] > self.size[b]:            a, b = b, a                    self.id[ra] = rb        self.size[rb] += self.size[ra]        self.ct -= 1            class Solution:    def findCircleNum(self, isConnected: List[List[int]]) -> int:                dsu = DSU()        for prov, info in enumerate(isConnected):            if prov not in dsu.id:                dsu.add(prov)            for other, con in enumerate(info):                if other != prov and con == 1:                    if other not in dsu.id:                        dsu.add(other)                    dsu.union(prov, other)        return dsu.ct                    