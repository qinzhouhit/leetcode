'''keys: Solutions:Similar: T:S:'''from typing import Listimport collections# Definition for a binary tree node.class TreeNode:    def __init__(self, x):        self.val = x        self.left = None        self.right = Noneclass Solution:    # O(N) for S and T, N as number of nodes in the tree    def distanceK(self, root: TreeNode, target: TreeNode, K: int) -> List[int]:        graph = collections.defaultdict(list)        def connect(parent, child):            # building an undirected graph representation, assign the            # child value for the parent as the key and vice versa            if parent and child:                graph[parent.val].append(child.val)                graph[child.val].append(parent.val)            if child.left: # in-order traversal                connect(child, child.left)            if child.right:                connect(child, child.right)                    connect(None, root)# the initial parent node of the root is None        # start the breadth-first search from the target,         # hence the starting level is 0        bfs = [target.val]        seen = set(bfs)        # all nodes at (k-1)th level must also be K steps away from the target node        for i in range(K):            # expand the list comprehension to strip away the complexity            new_level = []            for q_node_val in bfs:                for connected_node_val in graph[q_node_val]:                    if connected_node_val not in seen:                        new_level.append(connected_node_val)            bfs = new_level            print (bfs)            # add all the values in bfs into seen (union)            seen |= set(bfs)        return bfs                    