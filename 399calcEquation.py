'''keys: Solutions:Similar: T:S:'''from typing import Listfrom collections import defaultdict, dequeimport collectionsclass Solution:    # union find, T: O(e + q); S: O(e)    def calcEquation3(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:                    # DFS, huahua, O(e + q*e), q as query, e as edge    # S: O(e)    def calcEquation2(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:        def divide(x, y, visited):            if x == y: return 1.0            visited.add(x)            for n in g[x]:                if n in visited: continue                visited.add(n)                d = divide(n, y, visited) # d = n/y                if d > 0:                     return d * g[x][n] # n/y * x/n = x/y            return -1.0            g = collections.defaultdict(dict)        for (x, y), v in zip(equations, values):                  g[x][y] = v            g[y][x] = 1.0 / v                ans = [divide(x, y, set()) if x in g and y in g else -1 \               for x, y in queries]        return ans                            # simply build the graph with given equations,     # and traverse the graph, either DFS or BFS, to find a path    # for a given query, and the result is the product of costs of     # edges on the path.        '''    One optimization, which is not implemented in the code, is to "compress"    paths for past queries, which will make future searches faster. This is     the same idea used in compressing paths in union find set.     So after a query is conducted and a result is found, we add two edges    for this query if these edges are not already in the graph.    Given the number of variables N, and number of equations E, building     the graph takes O(E), each query takes O(N), space for graph takes O(E)    '''    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:        graph = {}        def build_graph(equations, values):            def add_edge(f, t, edge):                if f in graph:                    graph[f].append((t, value))                else:                    graph[f] = [(t, value)]                        for vertices, value in zip(equations, values):                x, y = vertices                add_edge(x, y, value)                add_edge(y, x, 1/value)                def find_path(query): # bfs            a, b = query                        if a not in graph or b not in graph:                return -1.0                            q = collections.deque([(a, 1.0)])            visited = set()                        while q:                front, cur_product = q.popleft()                if front == b:                    return cur_product                visited.add(front)                for neighbor, value in graph[front]:                    if neighbor not in visited:                        q.append((neighbor, cur_product*value))            return -1.0                build_graph(equations, values)        return [find_path(q) for q in queries]                        # optimized as suggested    def calcEquation1(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:        graph = defaultdict(dict) # dict of dict        for [x,y],value in zip(equations, values):            graph[x][y] = value            graph[y][x] = 1/value                def find_prod(s, e): # bfs            if s not in graph or e not in graph:                return -1.0            if s == e: return 1.0            q = deque([s, 1.0])            visited = {s}            while q:                n, curr = q.popleft()                for child, val in graph[n].items():                    if child in visited:                        continue                    nc = curr * val                    if child == e:                        return nc                    graph[s][child] = nc                    graph[child][s] = 1/nc                    visited.add(child)                    q.append((child, nc))            return -1.0                    return [find_prod(s, e) for s, e in queries] # s/e                        sol = Solution()print (sol.calcEquation([ ["a", "b"], ["b", "c"] ], [2.0, 3.0], \      [ ["a", "c"], ["b", "a"], ["a", "e"], ["a", "a"], ["x", "x"] ]))