'''keys: Solutions:Similar:T:S:'''from typing import Listimport heapqclass Solution:    # T: O(MNlog(MN))    # S: O(MN)    def maximumMinimumPath(self, A: List[List[int]]) -> int:        if not A:            return None                rows, cols = len(A), len(A[0])        steps = [(-1, 0), (1,0), (0, -1), (0, 1)]        stack = [(-A[0][0], 0, 0)]        seen = [[0] * cols for _ in range(rows)]        while stack:            # pop smallest (-x) one, i.e., pop max x, so next step is based            # on the maximum value            val, x, y = heapq.heappop(stack)            if x == rows - 1 and y == cols - 1:                return -val            for dx, dy in steps:                nx, ny = x + dx, y + dy                if 0 <= nx < rows and 0 <= ny < cols and not seen[nx][ny]:                    seen[nx][ny] = 1                    heapq.heappush(stack, (max(val, -A[nx][ny]), nx, ny))        return -1                    