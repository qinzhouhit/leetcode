'''keys: Solutions:Similar: T:S:'''from typing import Listclass Solution:    # # cyclic sort, faster    # try to place each number on its correct index    def findDuplicate(self, nums: List[int]) -> int:        i = 0        while i < len(nums):            if nums[i] != i + 1:                j = nums[i] - 1                if nums[i] != nums[j]:                    nums[i], nums[j] = nums[j], nums[i]  # swap                else:  # we have found the duplicate                    return nums[i]            else: # already in the correct position                i += 1        return -1    # cyclic sort, self-made, T: O(n); S: O(1)    def findDuplicate2(self, nums: List[int]) -> int:        i = 0; n = len(nums)-1        while i < n:            idx = nums[i] - 1            if nums[i] != nums[idx]:                nums[i], nums[idx] = nums[idx], nums[i]            else:                i += 1        for i in range(n):            if nums[i] != i+1:                return nums[i]        return nums[n]    # T: O(n); S: O(1), fast-slow pointers    # the array will have a cycle due to the duplicate number    # the start of the cycle will always point to the duplicate number    def findDuplicate1(self, nums: List[int]) -> int:        fast = slow = nums[0]        while True:            slow = nums[slow]            fast = nums[nums[fast]]            if slow == fast:                break # intersection                # find the entrance        slow = nums[0]        while slow != fast:            slow = nums[slow]            fast = nums[fast]        return fast                # T: O(nlogn); S: O(1); unfortunately sorting is against the requirement    def findDuplicate(self, nums: List[int]) -> int:        if not nums:            return None        nums.sort()        for i in range(1, len(nums)):            if nums[i] == nums[i-1]:                return nums[i]