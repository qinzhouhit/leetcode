'''keys: Solutions:Similar: T:S:'''from typing import Listclass Solution:        # bit manipulation; T: O(n), S: O(1)    # using XOR is its own inverse to find the missing element in linear time.    def missingNumber3(self, nums):        missing = len(nums)        for i, num in enumerate(nums):            # it works because of the associative/ commutative law            missing ^= i ^ num         return missing    # two pass bitwise xor    def missingNumber4(self, nums):        n = len(nums) + 1        x1 = 0        for i in range(1, n+1):            x1 = x1 ^ i # x1 representing numbers from 0 to n        x2 = nums[0] # x2 representing existing numbers        for num in nums[1:]            x2 = x2 ^ num        return x1 ^ x2        # T: O(n), S: O(1)    def missingNumber2(self, nums):        expected_sum = len(nums)*(len(nums)+1)//2        actual_sum = sum(nums)        return expected_sum - actual_sum        # cyclic sort, T: O(n); S: O(1)    def missingNumber4(self, nums: List[int]) -> int:        i, n = 0, len(nums)        while i < n:            idx = nums[i]            if idx < n and nums[i] != nums[idx]:                nums[i], nums[idx] = nums[idx], nums[i]            else:                i += 1        for i in range(n):            if nums[i] != i:                return i        return n        # self-made, O(n) for T    def missingNumber1(self, nums: List[int]) -> int:        for v in range(len(nums)+1):            if v not in nums:                return v                                    