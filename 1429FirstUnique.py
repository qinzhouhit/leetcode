'''keys: Solutions:Similar: T:S:'''from typing import Listimport deque'''LinkedHashSet: ordereddict in pythonA LinkedHashSet is a HashSet-LinkedList hybrid. Like a HashSet, items can be found, updated, added, and removed in O(1) time.'''# OrderedDict for queue and hashmap for status# In Python, we have to make do with the OrderedDict class. We can use it as a Set by setting# the values to None.from collections import OrderedDictclass FirstUnique2:    def __init__(self, nums: List[int]):        self._queue = OrderedDict()        self._is_unique = {}        for num in nums:            # Notice that we're calling the "add" method of FirstUnique; not of the queue.             self.add(num)            def showFirstUnique(self) -> int:        # Check if there is still a value left in the queue. There might be no uniques.        if self._queue:            # We don't want to actually *remove* the value.            # Seeing as OrderedDict has no "get first" method, the way that we can get            # the first value is to create an iterator, and then get the "next" value            # from that. Note that this is O(1).            return next(iter(self._queue))        return -1            def add(self, value: int) -> None:        # Case 1: We need to add the number to the queue and mark it as unique.         if value not in self._is_unique:            self._is_unique[value] = True            self._queue[value] = None        # Case 2: We need to mark the value as no longer unique and then         # remove it from the queue.        elif self._is_unique[value]:            self._is_unique[value] = False            self._queue.pop(value)        # Case 3: We don't need to do anything; the number was removed from the queue        # the second time it occurred.# queue and hashmap# S: O(N)class FirstUnique:    # we don't do delete since delete requires search over all nums    # which is O(N)    # T: O(K) for self.add, K as the number of nums in constructor    def __init__(self, nums: List[int]):        self._queue = deque(nums)        self._is_unique = {}        for num in nums:            self.add(num)    # O(1), amortized    def showFirstUnique(self) -> int:        while self._queue and not self._is_unique[self._queue[0]]:            self._queue.popleft() # O(1)        if self._queue:            return self._queue[0]        return -1            # T: O(1)    def add(self, value: int) -> None:        # Case 1: We need to add the number to the queue and mark it as unique.        if value not in self._is_unique:            self._is_unique[value] = True # O(1)            self._queue.append(value) # O(1)        # Case 2 and 3: We need to mark the number as no longer unique.        else:            self._is_unique[value] = False # O(1)                # LTEclass FirstUnique:    # O(K), K as length of initial nums    def __init__(self, nums: List[int]):        self._queue = deque(nums)    # O(N^2), N as the length of nums    # O(N) for counting a number    def showFirstUnique(self) -> int:        for item in self._queue:            if self._queue.count(item) == 1:                return item        return -1        # O(1)    def add(self, value: int) -> None:        self._queue.append(value)