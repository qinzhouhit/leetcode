'''keys: Solutions:Similar:T:S:'''from typing import Listclass Solution:    # educative.io version    # T: O(N*M*Len) where ‘N’ is the number of characters in the     # given string, ‘M’ is the total number of words, and ‘Len’     # is the length of a word.    # S: O(M) since at most, we will be storing all the words in     # the two HashMaps. In the worst case, we also need O(N)O(N)     # space for the resulting list. So, the overall space complexity     # of the algorithm will be O(M+N).O(M+N).    def findSubstring1(self, s: str, words: List[str]) -> List[int]:        if len(words) == 0 or len(words[0]) == 0:            return []        from collections import Counter        word_freq = Counter(words)                res_idxs = []        words_num = len(words)        word_len = len(words[0])                for i in range(len(s) - words_num*word_len + 1):            words_seen = {}            for j in range(words_num):                nxt_word_idx = i + j * word_len                word = s[nxt_word_idx: nxt_word_idx+word_len]                if word not in word_freq:                    break                # If a word is not found or has a higher frequency                # than required, we can move on to the next                 # character in the string.                if word not in words_seen: # O(len), char by char compare                    words_seen[word] = 0                words_seen[word] += 1                if words_seen[word] > word_freq.get(word, 0):                    break                if j + 1 == words_num:                    res_idxs.append(i)        return res_idxs                                    # TLE, use permutation    def findSubstring(self, s: str, words: List[str]) -> List[int]:        result_indices = []      # TODO: Write your code here        from itertools import permutations        tmp = permutations(words)        perms = []        for l in tmp:            perms.append("".join(l))        import collections         def helper(str1, pattern):            idxs = []            p_ct = collections.Counter(pattern)            l = 0            matched = 0            for r, c in enumerate(str1):                if c in p_ct:                    p_ct[c] -= 1                    if p_ct[c] == 0:                        matched += 1                if matched == len(p_ct) and pattern == str1[l:r+1]:                    idxs.append(l)                if r-l+1 >= len(pattern):                    l_c = str1[l]                    l += 1                    if l_c in p_ct:                        if p_ct[l_c] == 0:                            matched -= 1                        p_ct[l_c] += 1            return idxs        for perm in perms:            res = helper(s, perm)            for i in res:                if i not in result_indices:                    result_indices.append(i)        return result_indices                                                