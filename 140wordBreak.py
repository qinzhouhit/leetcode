'''keys: dpSolutions:Similar: T:S:'''from typing import Listfrom collections import defaultdict, Counterclass Solution:            ##############    '''    top-down: Let N be the length of the input string and     W be the number of words in the dictionary.    T: O(N^2 + 2^N + W)    S: O(2^N * N + W)    '''    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:        wordSet = set(wordDict)        # table to map a string to its corresponding words break        # {string: [['word1', 'word2'...], ['word3', 'word4', ...]]}        memo = defaultdict(list)                def _wordBreak_topdown(s):            # return list of word lists            if not s:                return [[]]                        if s in memo:                return memo[s]                        for endIdx in range(1, len(s)+1):                word = s[:endIdx]                if word in wordSet:                    for subsentence in _wordBreak_topdown(s[endIdx:]):                        memo[s].append([word]+subsentence)            return memo[s]                _wordBreak_topdown(s)        return [" ".join(words) for words in memo[s]]        ##############    def helper(self, s, wordDict, memo):        if s in memo: return memo[s]        if not s: return []                res = []        for word in wordDict:            if not s.startswith(word):                continue            if len(word) == len(s):                res.append(word)            else:                resultOfTheRest = self.helper(s[len(word):], wordDict, memo)                for item in resultOfTheRest:                    item = word + ' ' + item                    res.append(item)        print (res)        memo[s] = res        return res        def wordBreak2(self, s, wordDict):        """        :type s: str        :type wordDict: Set[str]        :rtype: List[str]        """        return self.helper(s, wordDict, {})            ##############    # bottom-up    def wordBreak1(self, s: str, wordDict: List[str]) -> List[str]:        # quick check on the characters,        # otherwise it would exceed the time limit for certain test cases.        if set(Counter(s).keys()) > set(Counter("".join(wordDict)).keys()):            return []        wordSet = set(wordDict)        dp = [[]] * (len(s)+1)        dp[0] = [""]        for endIndex in range(1, len(s)+1):            sublist = []            # fill up the values in the dp array.            for startIndex in range(0, endIndex):                word = s[startIndex:endIndex]                if word in wordSet:                    for subsentence in dp[startIndex]:                        sublist.append((subsentence + ' ' + word).strip())            dp[endIndex] = sublist        return dp[len(s)]        sol = Solution()sol.wordBreak2("catsanddog", ["cat", "cats", "and", "sand", "dog"])        