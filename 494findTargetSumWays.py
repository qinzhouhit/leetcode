'''keys: https://leetcode.com/problems/target-sum/discuss/97334/Java-(15-ms)-C%2B%2B-(3-ms)-O(ns)-iterative-DP-solution-using-subset-sum-with-explanationSolutions:Similar: T:S:'''from typing import Listclass Solution:    # dp    '''    sum(P) - sum(N) = target    sum(P) + sum(N) + sum(P) - sum(N) = target + sum(P) + sum(N)    2 * sum(P) = target + sum(nums)    '''    def findTargetSumWays2(self, nums: List[int], S: int) -> int:        sum_ = sum(nums)        if ((S + sum_) & 1) or sum_ < S:            return 0        else:            return self.helper1(nums, (S + sum_)//2)            def helper1(self, nums, S):        dp = [0] * (S+1)        dp[0] = 1        for i in range(len(nums)):            for j in range(S, nums[i]-1, -1):                dp[j] += dp[j - nums[i]]        return dp[S]                                # recursion + memo    # T and S: O(l*n)    def findTargetSumWays1(self, nums: List[int], S: int) -> int:        def helper(i, s):            if (i, s) not in memo:                r = 0                if i == len(nums):                    if s == 0:                        r = 1                else:                    r = helper(i+1, s-nums[i]) + helper(i+1, s+nums[i])                memo[(i, s)] = r            return memo[(i, s)]                memo = {}        return helper(0, S)            # recursion    # T: O(2^n); S: O(n), n = len(nums)    ct = 0    def findTargetSumWays(self, nums: List[int], S: int) -> int:        self.helper(nums, 0, 0, S)        return self.ct        def helper(self, nums, i, sum_, S):        if i == len(nums):            if sum_ == S:                self.ct += 1        else:            self.helper(nums, i+1, sum_+nums[i], S)            self.helper(nums, i+1, sum_-nums[i], S)        