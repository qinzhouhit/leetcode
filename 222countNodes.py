'''keys:Solutions:Similar:T:S:'''from typing import List# Definition for a binary tree node.class TreeNode:    def __init__(self, val=0, left=None, right=None):        self.val = val        self.left = left        self.right = rightclass Solution:        # T: O(d^2) = O((logN)^2)    def countNodes2(self, root):        if not root:            return 0        leftDepth = self.getDepth(root.left)        rightDepth = self.getDepth(root.right)        if leftDepth == rightDepth:            # left subtree is perfect binary tree            # right subtree is complete binary tree            return pow(2, leftDepth) + self.countNodes(root.right)        else: # left subtree height greather than right            # left subtree is complete binary tree            # right subtree is perfect binary tree            return pow(2, rightDepth) + self.countNodes(root.left)            def getDepth(self, root):            if not root:                return 0            return 1 + self.getDepth(root.left)        # binary search     # T: O(d^2) = O((logN)^2), d as tree depth    # S: O(1)    def compute_depth(self, node: TreeNode) -> int:        # Return tree depth in O(d) time.        d = 1        while node.left:            node = node.left            d += 1        return d    def exists(self, idx: int, d: int, node: TreeNode) -> bool:        """        Last level nodes are enumerated from 0 to 2**d - 1 (left -> right).        Return True if last level node idx exists.         Binary search with O(d) complexity.        """        path = []        while idx > 0:            path.append(idx)            idx //= 2 # go to next level        for i in range(len(path)-1, -1, -1):            if not node:                return False            if i == 0:                return True            # print (path[i-1], path[i])            if path[i-1] == path[i]*2:                node = node.left # go to left child, e.g., 1 -> 2            else: # go right, e.g., 1 -> 3                node = node.right        # return False                    def countNodes1(self, root: TreeNode) -> int:        # if the tree is empty        if not root:            return 0                d = self.compute_depth(root)        # if the tree contains 1 node        if d == 1:            return 1                # Last level nodes are enumerated from 0 to 2**d - 1 (left -> right).        # Perform binary search to check how many nodes exist.        left, right = 2**(d-1), 2**d - 1        while left <= right:            pivot = left + (right - left) // 2            # print (left, right, pivot)            if self.exists(pivot, d, root):                left = pivot + 1            else:                # print ("no pivot")                right = pivot - 1                # The tree contains 2**d - 1 nodes on the first (d - 1) levels        # and left nodes on the last level.        return left - 1            # T: O(N); S: O(logN) for the stack    def countNodes(self, root: TreeNode) -> int:        return 1 + self.countNodes(root.left) + self.countNodes(root.right)\            if root else 0                                