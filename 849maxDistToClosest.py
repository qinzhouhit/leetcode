'''keys: Solutions:Similar:T:S:'''from typing import Listclass Solution:    # one pass: T: O(N); S: O(1)    '''last is the index of last seated seat. Loop on all seats, when we met     a people, we count the distance from the last. The final result =     max(distance at the beginning, distance in the middle / 2, distance at     the end).    '''    def maxDistToClosest1(self, seats):        res, last, n = 0, -1, len(seats)        for i in range(n):            if seats[i]: # if seats at i is taken                if last == -1:  # i is the first seat ever met                    res = i # this take care of the edge case 1 when position 0 is not taken                else:                    # normal case:                    res = max(res, (i-last)//2)                # update the most recent taken seat                last = i        # at last, check the edge case 2        res = max(res, n-last-1)        return res        # self-made    def maxDistToClosest(self, seats: List[int]) -> int:        idxs = [] # all idx of 1        for idx, val in enumerate(seats):            if val == 1:                idxs.append(idx)        # corner case        if len(idxs) == 1:            idx = idxs[0]            if abs(idx-0) >= abs(len(seats)-1-idx):                return idx            else:                return len(seats)-1-idx        # find longest 0 sequence in the list        maxx = (0, 0, len(seats)-1)        for i in range(len(idxs)-1):            prev, nxt = idxs[i], idxs[i+1]            if nxt - prev > maxx[0]:                maxx = (nxt - prev, prev, nxt)        # insert 1 into the longest 0 sequence        tmp = (maxx[1] + maxx[2]) // 2        tmp_dis = min(tmp-maxx[1], maxx[2]-tmp)        # corner case, left end is 0s or right end is 0s        left_dis = idxs[0]        right_dis = len(seats) - 1 - idxs[-1]        return max(tmp_dis, left_dis, right_dis)