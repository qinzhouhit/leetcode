'''keys: Solutions:Similar: T:S:'''from typing import Listimport heapqclass Solution:    # naive    def maxEvents2(self, events: List[List[int]]) -> int:        events.sort(key=lambda x: (x[1], x[0]))        res = 0        seen = [0]*100001        for e in events:            for i in range(e[0], e[1]+1):                if seen[i]: # day i already used                    continue                seen[i] = 1                res += 1                break        return res            # greedy, heapq    # data structures / algorithm have you learned that can efficiently     # keep track of the biggest value, while you can dynamically add and     # remove elements? Binary search/insert and min/max heap; BST/ heapq    # T: O(d + nlogn); where D is the range of events[i][1]    # S: O(n)    def maxEvents3(self, events: List[List[int]]) -> int:        events.sort() # sort by start time, ascending        total_days = max(events[1] for event in events)        min_heap = [] # keeping all available events        day, cnt, event_idx = 1, 0, 0        while day <= total_days:            # if no events are available to attend today,             # let time flies to the next available event.            if event_idx < len(events) and not min_heap:                day = events[event_idx][0]						# all events starting from today are newly available.             # add them to the heap.            while event_idx < len(events) and events[event_idx][0] <= day:                heapq.heappush(min_heap, events[event_idx][1])                event_idx += 1			# if the event at heap top already ended, then discard it.            while min_heap and min_heap[0] < day:                heapq.heappop(min_heap)			# attend the event that will end the earliest            if min_heap:                heapq.heappop(min_heap)                cnt += 1            elif event_idx >= len(events):                break  # no more events to attend. so stop early to save time.            day += 1        return cnt                    def maxEvents(self, events: List[List[int]]) -> int:        events.sort(reverse=True) # decreasing by start time        heap = []        res = d = 0 # d is the current date?        while events or heap:            if not heap:                 d = events[-1][0] # latest starting date            # Add new events that can attend on day `d`            while events and events[-1][0] <= d:                # key of priority queue: ending date                heapq.heappush(heap, events.pop()[1])            heapq.heappop(heap) # the one with smallest/earliest ending date            res += 1            d += 1            while heap and heap[0] < d:                 # if the event at heap top already ended, then discard it.                heapq.heappop(heap)        return res            # not intuitive greedy one    def maxEvents1(self, events: List[List[int]]) -> int:        events.sort(key=lambda x: x[1])        days = set()        for start, end in events:            if start not in days:                days.add(start)            else:                i = start + 1 # start in days, so we can greedily choose the next day                while i in days and i <= end:                    i += 1                if i <= end: # meaning day_i can be chose                    days.add(i)        return len(days)            