'''keys: Solutions:Similar:T:S:'''from typing import List# anti-diagonal: idx = x + y, hill diagonal# diagonal: idx = x - y + (n-1), dale diagonalclass Solution:    # T: O(N!): N choices for first queen, N-1 for 2nd, etc.    # S: O(N) for tracking diagonals and rows    def solveNQueens(self, n: int) -> List[List[str]]:                def could_place(r, c):            # all of the three can not be 1            return not (cols[c] + anti_diagonal[r-c] + diagonal[r+c])                def place_queen(r, c):            queens.add((r, c))            cols[c] = 1 # exclude the c, don't need to check for the row            # since we are at this row            anti_diagonal[r - c] = 1            diagonal[r + c] = 1                    def remove_queen(r, c):            queens.remove((r, c))            cols[c] = 0 # exclude the r and c            anti_diagonal[r - c] = 0            diagonal[r + c] = 0                    def add_solution():            solution = []            for _, c in sorted(queens):                solution.append('.' * c + 'Q' + '.' * (n - c - 1))            res.append(solution)                def backtrack(r = 0):            for c in range(n):                if could_place(r, c):                    place_queen(r, c)                    if r + 1 == n: # reaching last row                        add_solution()                    else:                        backtrack(r + 1)                    remove_queen(r, c)                        cols = [0] * n        diagonal = [0] * (2*n-1)        anti_diagonal = [0] * (2*n-1)        queens = set()        res = []        backtrack(0)        return res