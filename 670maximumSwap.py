'''keys: Solutions:Similar: T:S:'''from typing import List# swap two digits at most onceclass Solution:    # O(N) for T and S    # if there is a larger digit in the future, we will swap it with     # the largest such digit; if there are multiple such digits, we will    # swap it with the one that occurs the furthest.    def maximumSwap1(self, num: int) -> int:        A = list(str(num))        last = {int(digit): idx for idx, digit in enumerate(A)}        for idx, digit in enumerate(A):            for d in range(9, int(digit), -1): # consider from the biggest digit                # larger digit in later part, swap it and only once                # if this larger digit does not exist, set its fake idx as 0 or                 # a smaller value, making sure it's smaller than or equal to idx                if last.get(d, 0) > idx:                     A[idx], A[last[d]] = A[last[d]], A[idx]                    return int("".join(map(str, A)))        return num                            # O(N^3), N^2 for two loops, and O(N) for comparing two sequences    # O(N) for S    def maximumSwap(self, num: int) -> int:        A = list(str(num))        res = A[:] # deep copy        for i in range(len(A)):            for j in range(i+1, len(A)):                A[i], A[j] = A[j], A[i]                if A > res: res = A[:]                A[i], A[j] = A[j], A[i]        return int("".join(res))        sol = Solution()print (sol.maximumSwap1("37885"))