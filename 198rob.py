'''keys: most dp: from recursion -> recursion + memoization -> dpFrom top-down to bottom-up, then reducing dimension, e.g., O(n^2) to O(n)or O(n) to O(1)https://leetcode.com/problems/house-robber/discuss/156523/From-good-to-great.-How-to-approach-most-of-DP-problems.Solutions:Similar: 740T:S:'''from typing import Listclass Solution:    # greedy expansion    # dp: O(n) as the number of hourse    # T: O(1)    # rob(n) = max(rob(n-2) + money[i], rob(n-1))    def rob1(self, nums: List[int]) -> int:        if not nums: return 0        preMax = 0; curMax = 0        for num in nums:            temp = curMax            curMax = max(preMax + num, curMax) # curMax: not rob; preMax: rob + prepre            preMax = temp        return curMax                # O(n) dp    def rob(self, nums: List[int]) -> int:        if not nums: return 0        dp = [0] * len(nums)        for i in range(len(nums)):            if i == 0:                dp[i] = max(nums[i], 0)            elif i == 1:                dp[i] = max(nums[i], dp[i-1])            elif i >= 2:                dp[i] = max(dp[i-2] +nums[i], dp[i-1])        return dp[-1]    # O(N) for memo    def rob(self, nums: List[int]) -> int:        self.memo = {}        return self.helper(0, nums)            def helper(self, i, nums):        if i >= len(nums):            return 0                if i in self.memo:            return self.memo[i]                res = max(self.helper(i+1, nums), self.helper(i+2, nums)+nums[i])        self.memo[i] = res        return self.memo[i]