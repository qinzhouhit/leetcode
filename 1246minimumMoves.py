'''keys: Solutions:Similar: T:S:'''from typing import Listclass Solution:    # understandable    def minimumMoves2(self, arr: List[int]) -> int:        if not arr or len(arr) == 0:            return 0        n = len(arr)        # dp[i][j]: min moves for subarray [i:j]        dp = [[0 for _ in range(n)]                  for _ in range(n)]                 for i in range(n):            dp[i][i] = 1                for j in range(n): # j is the vertical index            for i in range(j-1, -1. -1): # along the diagonal, to the left                if i == j - 1: # i.e., length of subarray is 2                    dp[i][j] = 1 if arr[i] == arr[j] else 2                    continue                min_ = float("inf")                if arr[i] == arr[j]:                    min_ = min(min_, dp[i+1][j-1])                # two subarrays [i:k], [k+1:j]                for k in range(i, j):                    min_ = min(min_, dp[i][k] + dp[k+1][j])                dp[i][j] = min_        return dp[0][n-1]                                                                    # DP, top-down    # A[i] can be removed alone or it makes a pair.    def minimumMoves(self, arr: List[int]) -> int:        def dp(i, j):            if i > j:                 return 0            res = dp(i, j - 1) + 1            if arr[j] == arr[j - 1]:                res = min(res, dp(i, j - 2) + 1)            for k in range(i, j - 1):                if arr[j] == arr[k]:                    res = min(res, dp(i, k - 1) + dp(k + 1, j - 1))            return res        return dp(0, len(arr) - 1)            # geeks for geeks    def minimumMoves1(self, arr: List[int]) -> int:        N = len(str)           # declare dp array and initialize          # it with 0s         dp = [[0 for _ in range(N + 1)]                  for _ in range(N + 1)]               # loop for substring length we are considering         for l in range(1, N + 1):             # loop with two variables i and j, denoting             # starting and ending of substrings             i = 0            j = l - 1            while j < N:                 # If substring length is 1,                  # then 1 step will be needed                 if (l == 1):                     dp[i][j] = 1                else:                     # delete the ith char individually                     # and assign result for subproblem (i+1,j)                     dp[i][j] = 1 + dp[i + 1][j]                     # if current and next char are the                    # same, choose min from current                      # and subproblem (i+2,j)                     if (str[i] == str[i + 1]):                         dp[i][j] = min(1 + dp[i + 2][j], dp[i][j])                     ''' loop over all right characters and suppose                         Kth char is same as ith character then                         choose minimum from current and two                         substring after ignoring ith and Kth char '''                    for k in range(i + 2, j + 1):                         if (str[i] == str[k]):                             dp[i][j] = min(dp[i + 1][k - 1] +                                            dp[k + 1][j], dp[i][j])                              i += 1                j += 1        # Uncomment below snippet to print          # actual dp tablex          # for (int i = 0; i < N; i++, cout << endl)         # for (int j = 0; j < N; j++)         #     cout << dp[i][j] << " ";                return dp[0][N - 1] 