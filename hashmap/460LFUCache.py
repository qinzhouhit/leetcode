'''keys: OrderedDict is a dict + double linked list.A freq2node is a dict of OrderedDict, so you can look up like this: freq2node[freq][key] to remove/update the node in O(1), or freq2node[freq].popitem(last=True) to remove the oldest node in O(1).Popping the nodes with Solutions:Similar: T:S:'''from typing import Listfrom collections import defaultdictfrom collections import OrderedDict# https://leetcode.com/problems/lfu-cache/discuss/166683/Python-only-use-OrderedDict-get-O(1)-put-O(1)-Simple-and-Brief-Explained!!!!!!class Node:    def __init__(self, key, val, freq):        self.key = key        self.val = val        self.freq = freq        class LFUCache:    def __init__(self, capacity: int):        self.cap = capacity        self.key2node = {} # k: key, v: Node object, 1to1 mapping        # k: frequency, v: list of k-v pairs with k1: key, v1: Nodes        self.freq2node = defaultdict(OrderedDict)        self.minFreq = None            def get(self, key: int) -> int:        if key not in self.key2node:            return -1        node = self.key2node[key]        # delete the node from the current frequency list        del self.freq2node[node.freq][key]        # insert the node the higher frequency list        # actually it's instered to the very beginning        node.freq += 1        self.freq2node[node.freq][key] = node        # # if current frequency no longer has node        # if not self.freq2node[node.freq]:        #     del self.freq2node[node.freq]        # increase minFreq if minFreq list no longer has node        if not self.freq2node[self.minFreq]:            self.minFreq += 1                return node.val            def put(self, key: int, value: int) -> None:        if not self.cap: # capacity is 0, boring case...            return                 if key in self.key2node:            self.key2node[key].val = value            self.get(key) # update frequency, put makes freq+1 too            return                # When the cache reaches its capacity, it should invalidate and         # remove the least frequently used key before inserting a new item.        # if add new node first, then the new node will be removed...        if len(self.key2node) == self.cap:            # OrderedDict.popitem(last=True) is LIFO            # OrderedDict.popitem(last=False) is FIFO, like queue,             # here popoing the least used one (earliest accessed) with least frequency            # it return key and value!!!            k, n = self.freq2node[self.minFreq].popitem(last=False)             del self.key2node[k]                 # add the new Node to the frequency list        # the node exists in the key2node and freq2node        self.key2node[key] = Node(key, value, 1)        self.freq2node[1][key] = Node(key, value, 1)        # for new node, the frequency is 1        self.minFreq = 1        return # not necessary# Your LFUCache object will be instantiated and called as such:# obj = LFUCache(capacity)# param_1 = obj.get(key)# obj.put(key,value)                                                        