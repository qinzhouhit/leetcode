'''keys: Solutions:Similar: T:S:'''from typing import Listclass Solution:    # >>> dfs    # https://leetcode.com/problems/interleaving-string/discuss/31885/Python-DP-solutions-(O(m*n)-O(n)-space)-BFS-DFS.    # T: O(m*n), S: O(n), m and n for l1 and l2    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:        l1, l2, l3 = len(s1), len(s2), len(s3)        if l1 + l2 != l3:            return False        stack, visited = [(0, 0)], set((0, 0))        while stack:            i, j = stack.pop() # ptr for s1 and s2            if i + j == l3:                return True            if i <= l1 - 1 and s1[i] == s3[i+j] and (i+1, j) not in visited:                visited.add((i+1, j))                stack.append((i+1, j))            if j <= l2 - 1 and s2[j] == s3[i+j] and (i, j+1) not in visited:                visited.add((i+1, j))                stack.append((i+1, j))        return False    # >>> backtrack    # T: O(2^(m+n)) for T    # S: O(m+n) for stack    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:        return self.helper(s1, 0, s2, 0, "", s3)    @functools.lru_cache(maxsize=None)    def helper(self, s1, i, s2, j, res, s3): # res is the cur         if res == s3 and i == len(s1) and j == len(s2):            return True        ans = False        if i < len(s1):            ans |= self.helper(s1, i+1, s2, j, res+s1[i], s3)        if j < len(s2):            ans |= self.helper(s1, i, s2, j+1, res+s2[j], s3)        return ans    # >>> 2D DP    # https://leetcode.com/problems/interleaving-string/discuss/31879/My-DP-solution-in-C%2B%2B    '''    DP table represents if s3 is interleaving at (i+j)th position when s1     is at ith position, and s2 is at jth position. 0th position means empty string.    So if both s1 and s2 is currently empty, s3 is empty too, and it is     considered interleaving. If only s1 is empty, then if previous s2 position    is interleaving and current s2 position char is equal to s3 current position    char, it is considered interleaving. similar idea applies to when s2 is     empty. when both s1 and s2 is not empty, then if we arrive i, j from i-1,    j, then if i-1,j is already interleaving and i and current s3 position     equal, it s interleaving. If we arrive i,j from i, j-1, then if i, j-1     is already interleaving and j and current s3 position equal. it is     interleaving.    '''    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:                if len(s3) != len(s1) + len(s2):            return False        # len(s1) + 1 rows; len(s2) + 1 columns        # dp[i][j] for s1[0:i] and s2[0:j]        dp = [[False] * (len(s2)+1) for _ in range(len(s1)+1)]                for i in range(len(s1)+1): # rows, i-1 is the idx for s1            for j in range(len(s2)+1): # col, j-1 is the idx for s2                if i == 0 and j == 0:                    dp[i][j] = True                elif i == 0: # previous T and s2 cur char == s3 cur char                    dp[i][j] = (dp[i][j-1] and s2[j-1] == s3[i+j-1])                elif j == 0: # previous T and s1 cur char == s3 cur char                    dp[i][j] = (dp[i-1][j] and s1[i-1] == s3[i+j-1])                else: # arrive i, j from i-1, j, i and current s3 position equal                    # arrive i,j from i, j-1, then if i, j-1 is already interleaving                    dp[i][j] = (dp[i-1][j] and s1[i-1] == s3[i+j-1] ) \                        or (dp[i][j-1] and s2[j-1] == s3[i+j-1])        return dp[len(s1)][len(s2)]