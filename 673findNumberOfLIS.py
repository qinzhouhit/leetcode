'''keys: Solutions:Similar: T:S:'''from typing import List'''i, j, lens, ctsi: 3 ,j: 0 [1, 1, 1, 1] [1, 1, 1, 1]case1 [1, 1, 1, 2] [1, 1, 1, 1] # j = 0 -> lens[3] = 2i: 3 ,j: 1 [1, 1, 1, 2] [1, 1, 1, 1]case2 [1, 1, 1, 2] [1, 1, 1, 2] # j = 1 -> cts[3] = 2, i.e., 2 ways, 0->3, 1->3i: 3 ,j: 2 [1, 1, 1, 2] [1, 1, 1, 2]case2 [1, 1, 1, 2] [1, 1, 1, 3]'''class Solution:    # T: O(N^2); S: O(N)    # lengths[i] = the length of longest subsequence in nums[:i] and     # ending in nums[i]    # count[i] = number of subsequence satisfying above condiction    # ending in nums[i]    # https://leetcode.com/problems/number-of-longest-increasing-subsequence/discuss/697315/JAVA-Simple-DP-Solution-with-Explanataion    def findNumberOfLIS(self, nums: List[int]) -> int:        n = len(nums)        if n <= 1:            return n        lens = [1] * n # one element as a subsequence        cts = [1] * n # one appearance        for i in range(n):            for j in range(i): # j < i, e.g., [X, X, j, X, i, ...]                if nums[i] > nums[j]: # increasing                    # you find a subsequence, but its length is smaller                     # compared to LIS which ends with nums[i].                    # # in case current IS's length > length of LIS seen so far                    if lens[j] + 1 > lens[i]: # 1 refers to nums[i]                        lens[i] = lens[j] + 1                        cts[i] = cts[j] # cts don't change if we append nums[i] to all the subsequences                    # you find another subsequence with the same length of LIS                     # which ends with nums[i]                    # # in case current IS's length == length of LIS seen so far                    elif lens[j] + 1 == lens[i]: # 1 refers to nums[i]                        cts[i] += cts[j]        longest = max(lens)        return sum(c for i, c in enumerate(cts) if lens[i] == longest)        