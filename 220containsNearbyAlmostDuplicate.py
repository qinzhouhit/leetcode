'''keys: Solutions:Similar: T:S:'''from typing import Listfrom sortedcontainers import SortedList# http://www.grantjenks.com/docs/sortedcontainers/introduction.htmlclass Solution:    # bst; T: O(nlog(min(k, n))); S: O(min(n, k))    # bisect_left: the number of elements strictly less than val    # bisect_right: the number of elements less than or equal to val.    def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:        bst = SortedList()        for i in range(len(nums)):            if i > k:                 bst.remove(nums[i-k-1])                               pos1 = bst.bisect_left(nums[i] - t) # left boundary            pos2 = bst.bisect_right(nums[i] + t) # right boundary                        if pos1 != pos2 and pos1 != len(bst): # don't need pos1 != len(bst)                return True                        bst.add(nums[i])                return False            # bucket sort    # T: O(n); S: O(min(n, k))    # Any two elements that are not in the same or adjacent buckets must     # have a distance greater than t    # https://leetcode.com/problems/contains-duplicate-iii/discuss/61639/JavaPython-one-pass-solution-O(n)-time-O(n)-space-using-buckets    def containsNearbyAlmostDuplicate1(self, nums, k, t):        if t < 0: return False        n = len(nums)        d = {}        w = t + 1        for i in range(n):            m = nums[i] // w # bucket ID            if m in d: # current element in a bucket with other element(s)                 return True            # left neighboring bucket            if m - 1 in d and abs(nums[i] - d[m - 1]) < w:                return True            if m + 1 in d and abs(nums[i] - d[m + 1]) < w:                return True            d[m] = nums[i]            if i >= k:                 del d[nums[i - k] // w] # it's actually removing nums[i-k] in that bucket        return False                