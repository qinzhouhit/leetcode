'''keys: Solutions:Similar: T:S:'''from typing import Listclass Solution:    # T: O(R*C), R/C as the number of rows/cols    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:        seen = set()                def area(r, c):            if not (0 <= r < len(grid) and 0 <= c <len(grid[0]) and (r, c) not in seen and grid[r][c]):                return 0            seen.add((r, c))            return (1 + area(r+1, c) + area(r, c+1) \                    + area(r-1, c) + area(r, c-1))                return max(area(r, c) for r in range(len(grid)) \                   for c in range(len(grid[0])))                # iterative    def maxAreaOfIsland1(self, grid: List[List[int]]) -> int:        seen = set()        ans = 0        for r0, row in enumerate(grid):            for c0, val in enumerate(row):                if val and (r0, c0) not in seen:                    shape = 0                    stack = [(r0, c0)]                    seen.add((r0, c0))                    while stack:                        r, c = stack.pop()                        shape += 1                        for nr, nc in ((r-1, c), (r+1, c), (r, c-1), (r, c+1)):                            if (0 <= nr < len(grid) and 0 <= nc < len(grid[0])                                    and grid[nr][nc] and (nr, nc) not in seen):                                stack.append((nr, nc))                                seen.add((nr, nc))                    ans = max(ans, shape)        return ans    # LTE    if not grid:            return 0                res = 0        for i in range(len(grid)):            for j in range(len(grid[0])):                # if grid[i][j] == 1:                 tmp = self.helper(grid, i, j, set())                res = max(res, tmp)        return res        def helper(self, grid, i, j, seen):        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or (i, j) \                in seen or grid[i][j] != 1:            return 0        seen.add((i, j))        return 1 + self.helper(grid, i+1, j, seen) + self.helper(grid, i, j+1, seen)\         + self.helper(grid, i-1, j, seen) + self.helper(grid, i, j-1, seen)