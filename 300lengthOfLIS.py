'''keys: Solutions:Similar: T:S:'''from typing import List# similar question: 673class Solution:    # huahua method; O(n^2) for T and O(n) for S    def lengthOfLIS2(self, nums: List[int]) -> int:        if not nums: return 0        n = len(nums)        f = [1] * n        for i in range(1, n): # length of the subarray            for j in range(0, i): # all the shorter subarray                if nums[i] > nums[j]:                    f[i] = max(f[i], f[j] + 1)        return max(f)        # recursion with memoization    # based on last version    def helper1(self, nums, preindex, curindex, memo):        if curindex == len(nums):            return 0                def lengthOfLIS1(self, nums: List[int]) -> int:s        memo = [[-1]*(len(nums) + 1) for _ in range(len(nums))]        return self.helper1(nums, -1, 0, memo)            # brute force    # T: O(2^n) for recursion; S: O(n^2)    def lengthOfLIS(self, nums: List[int]) -> int:        return self.helper(nums, float("-inf"), 0)        def helper(self, nums, prev, cur):        # prev: previous small element        # cur: current index        if cur == len(nums):            return 0                taken = 0        if nums[cur] > prev:            taken = 1 + self.helper(nums, nums[cur], cur + 1)        nottaken = self.helper(nums, prev, cur + 1)        return max(taken, nottaken)    sol = Solution()sol.lengthOfLIS([1,3,2])                    