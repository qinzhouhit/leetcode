'''keys: Solutions:Similar: 334T:S:'''from typing import Listfrom bisect import bisect_left# similar question: 673class Solution:    # https://leetcode.com/problems/longest-increasing-subsequence/discuss/152065/Python-explain-the-O(nlogn)-solution-step-by-step    def lengthOfLIS4(self, nums: List[int]) -> int:        a = []        for num in nums:            idx = bisect_left(a, num)            if idx == len(a):                a.append(num)            else:                a[idx] = num        return len(a)        # optimal: T: O(nlogn); S: O(n), binary search    # https://leetcode.com/problems/longest-increasing-subsequence/discuss/74824/JavaPython-Binary-search-O(nlogn)-time-with-explanation    def lengthOfLIS3(self, nums: List[int]) -> int:        tails = [0] * len(nums)        size = 0        for num in nums:            l, r = 0, size            while l < r:                m = l + (r - l) // 2                if tails[m] < num:                    l = m + 1                else:                    r = m            tails[l] = num             size = max(l + 1, size)        return size                # huahua method; O(n^2) for T and O(n) for S    def lengthOfLIS2(self, nums: List[int]) -> int:        if not nums: return 0        n = len(nums)        f = [1] * n        for i in range(1, n): # length of the subarray            for j in range(0, i): # all the shorter subarray                if nums[i] > nums[j]:                    f[i] = max(f[i], f[j] + 1)        return max(f)        # recursion with memoization    # based on last version    def helper1(self, nums, preindex, curindex, memo):        if curindex == len(nums):            return 0                def lengthOfLIS1(self, nums: List[int]) -> int:        memo = [[-1]*(len(nums) + 1) for _ in range(len(nums))]        return self.helper1(nums, -1, 0, memo)            # brute force    # T: O(2^n) for recursion; S: O(n^2)    def lengthOfLIS(self, nums: List[int]) -> int:        return self.helper(nums, float("-inf"), 0)        def helper(self, nums, prev, cur):        # prev: previous small element        # cur: current index        if cur == len(nums):            return 0                taken = 0        if nums[cur] > prev:            taken = 1 + self.helper(nums, nums[cur], cur + 1)        nottaken = self.helper(nums, prev, cur + 1)        return max(taken, nottaken)    sol = Solution()sol.lengthOfLIS([1,3,2])                    