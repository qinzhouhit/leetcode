'''keys: Solutions:Similar: T:S:'''from typing import Listfrom heapq import heappush, heappushpop, heappop# follow up: https://leetcode.com/problems/find-median-from-data-stream/discuss/275207/Solutions-to-follow-ups'''1. If all integer numbers from the stream are between 0 and 100, how would you optimize it?We can maintain an integer array of length 100 to store the count of each number along with a total count. Then, we can iterate over the array to find the middle value to get our median.Time and space complexity would be O(100) = O(1).2. If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?In this case, we need an integer array of length 100 and a hashmap for these numbers that are not in [0,100].''''''Assume ‘x’ is the median of a list. This means that half of the numbers in the list will be smaller than (or equal to) ‘x’ and half will be greater than (or equal to) ‘x’. This leads us to an approach where we can divide  the list into two halves: one half to store all the smaller numbers (let’s  call it smallNumList) and one half to store the larger numbers (let’s call   it largNumList).'''# two heaps, O(logn)class MedianFinder3:    def __init__(self):        self.heaps = [], []    ##### understandable version    # T: O(logN) for insertion to heap, O(1) for findMedian    # S: O(N) for heap    def __init__(self):        """        Initialize your data structure here.        """        self.small = [] # store the small half, top is the largest in the small part, maxHeap        self.large = [] # store the large half, top is the smallest in the large part, minHeap        def addNum1(self, num):         """        Adds a num into the data structure.        :type num: int        :rtype: void        """        # self.small is maxheap, default is minheap.         if not self.small or num <= -self.small[0]: # make small the one with one extra val when odd number of vals            heapq.heappush(self.small, -num)        else: # num > -self.small[0]            # push to large part            heapq.heappush(self.large, num)        # adjust small and large balance        if len(self.small) - len(self.large) == 2:            heapq.heappush(self.large, -heapq.heappop(self.small))        elif len(self.small) - len(self.large) == -2:            heapq.heappush(self.small, -heapq.heappop(self.large))    def findMedian1(self): #         """        Returns the median of current data stream        :rtype: float        """        if len(self.small) == len(self.large):            return (self.large[0] - self.small[0])/2.0        return -float(self.small[0]) if len(self.small) > len(self.large) else float(self.large[0])    ##### concise version    # Max-heap small has the smaller half of the numbers, then max one will on be top    # Min-heap large has the larger half of the numbers, then min one will on be top    # "larger" has one more element than "small"    def addNum(self, num):        small, large = self.heaps        # move the minimum element of "large" into "small"        heappush(small, -heappushpop(large, num))        if len(large) < len(small):            heappush(large, -heappop(small))    def findMedian(self):        small, large = self.heaps        if len(large) > len(small):            return float(large[0])        return (large[0] - small[0]) / 2.0    # insertion sort: binary sort + insert    # always keep the list sorted     # O(n) for S and Tclass MedianFinder2:    def __init__(self):        """        initialize your data structure here.        """        self.store = []        self.n = len(self.store)    def addNum(self, num: int) -> None:        l, h = 0, len(self.store)-1        while l <= h:            mid = l + (h-l)//2            if num <= self.store[mid]:                h = mid - 1            else:                l = mid + 1        # print (l)        self.store.insert(l, num)        self.n += 1    def findMedian(self) -> float:        # print (self.store)        return (self.store[self.n//2] if self.n%2 else\                (self.store[self.n//2-1] + self.store[self.n//2])/2 )        # brute forceclass MedianFinder1:    def __init__(self):        """        initialize your data structure here.        """        self.store = []    def addNum(self, num: int) -> None:        self.store.append(num)    def findMedian(self) -> float:        self.store.sort()        n = len(self.store)        return (self.store[n//2] if n%2 else\                (self.store[n//2-1] + self.store[n//2])/2 )# Your MedianFinder object will be instantiated and called as such:# obj = MedianFinder()# obj.addNum(num)# param_2 = obj.findMedian()