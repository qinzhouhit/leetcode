'''keys: Solutions:Similar:T:S:'''from typing import Listimport collections# https://leetcode.com/problems/brick-wall/discuss/788421/Python-3-%2B-Dictionary-Explanationclass Solution:            # self-made    def leastBricks1(self, wall: List[List[int]]) -> int:                h = collections.defaultdict(int)        for row in wall:            idx = 0            for brick in row[:-1]:                idx += brick                h[idx] += 1        cts = h.values()        return len(wall) - (max(cts) if cts else 0)                        # T: O(n); S: O(m), n as number of bricks in a wall    # m refers to the width of the wall    def leastBricks(self, wall: List[List[int]]) -> int:        brickEndpointsToCount = {}                for bricks in wall:			# Initialise brickEndpoint to 0, i.e. the left-most point of the wall.            brickEndpoint = 0            			# Ignore the very last brick for each row since their endpoints             # are always the right-most part of the wall.            for i in range(len(bricks) - 1):                brick = bricks[i]				# Update the brickEndpoint by adding the length of the current                # brick in the row.                brickEndpoint += brick                				# We've seen this endpoint before, so increment the count.                if brickEndpoint in brickEndpointsToCount:                    brickEndpointsToCount[brickEndpoint] += 1				# This brickEndpoint hasn't been seen before, so initialise                 # the count to 1.                else:                    brickEndpointsToCount[brickEndpoint] = 1        		# Use this assignment to shorten the ternary operator in the return         # statement.        counts = brickEndpointsToCount.values()				# The solution is the number of rows of bricks (i.e. len(wall)) minus        # the maximum of the number of rows you can avoid by cutting through         # a certain brickEndpoint.        return len(wall) - (max(counts) if counts else 0)                    