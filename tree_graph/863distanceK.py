'''keys: Solutions:Similar: T:S:'''from typing import Listimport collections# Definition for a binary tree node.class TreeNode:    def __init__(self, x):        self.val = x        self.left = None        self.right = Noneclass Solution:    # self-made    # O(N) for S and T, N as number of nodes in the tree    def distanceK(self, root: TreeNode, target: TreeNode, K: int) -> List[int]:        # build a graph        graph = collections.defaultdict(list)                queue = deque([root])        while queue:            node = queue.popleft()            if node.left:                graph[node.val].append(node.left.val)                graph[node.left.val].append(node.val)                queue.append(node.left)            if node.right:                graph[node.val].append(node.right.val)                graph[node.right.val].append(node.val)                queue.append(node.right)                queue = deque([target.val]) # starting from target, expanding..        seen = set([target.val])        while K: # we only need to explore K layers            for _ in range(len(queue)): # exploring each layer                val = queue.popleft()                # print (queue)                for nei in graph[val]:                    if nei not in seen:                        queue.append(nei)                        seen.add(nei)            K -= 1        return list(queue) # vals left in queue are added vals for K-th layer                        # official, mark parent    def distanceK(self, root, target, K):        ans = []        # Return distance from node to target if exists, else -1        # Vertex distance: the # of vertices on the path from node to target        def dfs(node):            if not node:                return -1            elif node is target:                subtree_add(node, 0)                return 1            else:                L, R = dfs(node.left), dfs(node.right)                if L != -1:                    if L == K: ans.append(node.val)                    subtree_add(node.right, L + 1)                    return L + 1                elif R != -1:                    if R == K: ans.append(node.val)                    subtree_add(node.left, R + 1)                    return R + 1                else:                    return -1        # Add all nodes 'K - dist' from the node to answer.        def subtree_add(node, dist):            if not node:                return            elif dist == K:                ans.append(node.val)            else:                subtree_add(node.left, dist + 1)                subtree_add(node.right, dist + 1)        dfs(root)        return ans                    # O(N) for S and T, N as number of nodes in the tree    def distanceK(self, root: TreeNode, target: TreeNode, K: int) -> List[int]:        graph = collections.defaultdict(list)        def connect(parent, child):            # building an undirected graph representation, assign the            # child value for the parent as the key and vice versa            if parent and child:                graph[parent.val].append(child.val)                graph[child.val].append(parent.val)            if child.left: # in-order traversal                connect(child, child.left)            if child.right:                connect(child, child.right)                    connect(None, root)# the initial parent node of the root is None        # start the breadth-first search from the target,         # hence the starting level is 0        queue = [target.val]        seen = set(queue)        # all nodes at (k-1)th level must also be K steps away from the target node        for i in range(K):            # expand the list comprehension to strip away the complexity            new_level = []            for q_node_val in queue:                for connected_node_val in graph[q_node_val]:                    if connected_node_val not in seen:                        new_level.append(connected_node_val)            queue = new_level            # print (bfs)            # add all the values in bfs into seen (union)            seen |= set(queue)        return queue                    