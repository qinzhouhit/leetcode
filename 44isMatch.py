'''keys: Solutions:Similar: T:S:'''from typing import Listclass Solution:    # DP    def isMatch1(self, s: str, p: str) -> bool:        s_len = len(s)        p_len = len(p)                # base cases        if p == s or p == '*':            return True        if p == '' or s == '':            return False                # init all matrix except [0][0] element as False        d = [ [False] * (s_len + 1) for _ in range(p_len + 1)]        d[0][0] = True                # DP compute         for p_idx in range(1, p_len + 1):            # the current character in the pattern is '*'            if p[p_idx - 1] == '*':                s_idx = 1                # d[p_idx - 1][s_idx - 1] is a string-pattern match                 # on the previous step, i.e. one character before.                # Find the first idx in string with the previous match.                while not d[p_idx - 1][s_idx - 1] and s_idx < s_len + 1:                    s_idx += 1                # If (string) matches (pattern),                 # when (string) matches (pattern)* as well                d[p_idx][s_idx - 1] = d[p_idx - 1][s_idx - 1]                # If (string) matches (pattern),                 # when (string)(whatever_characters) matches (pattern)* as well                while s_idx < s_len + 1:                    d[p_idx][s_idx] = True                    s_idx += 1            # the current character in the pattern is '?'            elif p[p_idx - 1] == '?':                for s_idx in range(1, s_len + 1):                     d[p_idx][s_idx] = d[p_idx - 1][s_idx - 1]             # the current character in the pattern is not '*' or '?'            else:                for s_idx in range(1, s_len + 1):                     # Match is possible if there is a previous match                    # and current characters are the same                    d[p_idx][s_idx] = \                    d[p_idx - 1][s_idx - 1] and p[p_idx - 1] == s[s_idx - 1]                                                                         return d[p_len][s_len]                # recursion with memo    # O(min(S,P)) for the best case, and O(2^min(S,P/2)) for the worst case    def isMatch(self, s: str, p: str) -> bool:        p = self.remove_duplicate_stars(p)        print (p)        self.dp = {}        return self.helper(s, p)            def remove_duplicate_stars(self, p):        if p == '': return p        p1 = [p[0],]        for x in p[1:]:            # print (p1)            if p1[-1] != '*' or p1[-1] == '*' and x != '*':                p1.append(x)        return ''.join(p1)         def helper(self, s, p):        dp = self.dp        if (s, p) in dp:            return dp[(s, p)]                if p == s or p == '*':            dp[(s, p)] = True        elif p == '' or s == '': # empty string            dp[(s, p)] = False        elif p[0] == s[0] or p[0] == '?':             dp[(s, p)] = self.helper(s[1:], p[1:])        elif p[0] == '*': # match one char or the empty string            dp[(s, p)] = self.helper(s, p[1:]) or self.helper(s[1:], p)        else: dp[(s, p)] = False                return dp[(s, p)]        