'''keys: Solutions:Similar: 265T:S:'''from typing import Listfrom functools import lru_cacheclass Solution:        # dp; O(n) for T and O(1) for S; bottom up    def minCost3(self, costs: List[List[int]]) -> int:          if len(costs) == 0: return 0        for n in reversed(range(len(costs) - 1)):            # Total cost of painting n-th house red.            costs[n][0] += min(costs[n + 1][1], costs[n + 1][2])            # Total cost of painting n-th house green.            costs[n][1] += min(costs[n + 1][0], costs[n + 1][2])            # Total cost of painting n-th house blue.            costs[n][2] += min(costs[n + 1][0], costs[n + 1][1])            return min(costs[0]) # Return the minimum in the first row.            # dp; O(n) for T and real O(1) for S; bottom up    def minCost2(self, costs: List[List[int]]) -> int:        if len(costs) == 0: return 0        previous_row = costs[-1]        for n in reversed(range(len(costs) - 1)):                # PROBLEMATIC CODE IS HERE            # This line here is NOT making a copy of the original, it's simply            # making a reference to it Therefore, any writes into current_row            # will also be written into "costs". This is not what we wanted!                current_row = costs[n]                # Total cost of painting nth house red?            current_row[0] += min(previous_row[1], previous_row[2])            # Total cost of painting nth house green?            current_row[1] += min(previous_row[0], previous_row[2])            # Total cost of painting nth house blue?            current_row[2] += min(previous_row[0], previous_row[1])            previous_row = current_row            return min(previous_row)            # O(n) for S and T, with memoï¼Œtop-down    def minCost1(self, costs: List[List[int]]) -> int:                def paint_cost(n, color):            if (n, color) in self.memo:                return self.memo[(n, color)]            total_cost = costs[n][color]            if n == len(costs) - 1:                pass # skill ging further go straight to return            elif color == 0:                total_cost += min(paint_cost(n + 1, 1), paint_cost(n + 1, 2))            elif color == 1:                total_cost += min(paint_cost(n + 1, 0), paint_cost(n + 1, 2))            else:                total_cost += min(paint_cost(n + 1, 0), paint_cost(n + 1, 1))            self.memo[(n, color)] = total_cost            return total_cost            if costs == []:            return 0            self.memo = {}        return min(paint_cost(0, 0), paint_cost(0, 1), paint_cost(0, 2))        # lru; O(n) for S and T, with memo    def minCost(self, costs):        # If maxsize is set to None, the LRU feature is disabled and the cache        # can grow without bound.        @lru_cache(maxsize=None)        def paint_cost(n, color):            total_cost = costs[n][color]            if n == len(costs) - 1:                pass            elif color == 0:                total_cost += min(paint_cost(n + 1, 1), paint_cost(n + 1, 2))            elif color == 1:                total_cost += min(paint_cost(n + 1, 0), paint_cost(n + 1, 2))            else:                total_cost += min(paint_cost(n + 1, 0), paint_cost(n + 1, 1))            return total_cost        if costs == []:            return 0        return min(paint_cost(0, 0), paint_cost(0, 1), paint_cost(0, 2))