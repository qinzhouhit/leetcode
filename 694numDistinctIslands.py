'''keys: Solutions:Similar: T: O(R*C)S: O(R*C)'''from typing import Listclass Solution:    # Keeping track of the move in the DFS is enough for island signature.        def numDistinctIslands1(self, grid):        islands = set([])        for i in range(len(grid)):            for j in range(len(grid[i])):                if grid[i][j] == 1:                    islands.add(self.dfs(grid, i, j, "s"))        print (islands)        return len(islands)    def dfs(self, g, i, j, path):        if i < 0 or j < 0 or i >= len(g) or j >= len(g[i]) or g[i][j] == 0:            return ""        g[i][j] = 0 # mark it as seen        return path \               + self.dfs(g, i+1, j, "d") + "u" \               + self.dfs(g, i-1, j, "u") + "d" \               + self.dfs(g, i, j+1, "r") + "l" \               + self.dfs(g, i, j-1, "l") + "r"            def numDistinctIslands(self, grid: List[List[int]]) -> int:        seen = set()        def explore(r, c, di = 0):            if 0 <= r < len(grid) and 0 <= c < len(grid[0]) and \                grid[r][c] and (r, c) not in seen:                    seen.add((r, c))                    shape.append(di)                    explore(r+1,c,1)                    explore(r+1,c-1,2)                    explore(r,c+1,3)                    explore(r,c-1,4)                            shapes = set()        for r in range(len(grid)):            for c in range(len(grid[0])):                shape = []                explore(r, c)                if shape:                    shapes.add(tuple(shape))        print (shapes)        return len(shapes)    sol = Solution()print (sol.numDistinctIslands1([[1,1,0,1,1],[1,0,0,0,0],[0,0,0,0,1],[1,1,0,1,1]]))