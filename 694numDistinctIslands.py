'''keys: Solutions:Similar: T: O(R*C)S: O(R*C)'''from typing import Listclass Solution:    # Keeping track of the move in the DFS is enough for island signature.    # this is better    # O(R*C) for S and T    def numDistinctIslands2(self, grid):        islands = set()        for i in range(len(grid)):            for j in range(len(grid[i])):                if grid[i][j] == 1:                    islands.add(self.dfs(grid, i, j))        # print (islands)        return len(islands)    def dfs(self, g, i, j):        if i < 0 or j < 0 or i >= len(g) or j >= len(g[i]) or g[i][j] == 0:            return ""        g[i][j] = 0 # mark it as seen        return self.dfs(g, i+1, j) + "d" \               + self.dfs(g, i-1, j) + "u" \               + self.dfs(g, i, j+1) + "r" \               + self.dfs(g, i, j-1) + "l"            # why not working?    def numDistinctIslands1(self, grid: List[List[int]]) -> int:        seen = set()         def explore(r, c, di = 0):            if 0 <= r < len(grid) and 0 <= c < len(grid[0]) and \                grid[r][c] and (r, c) not in seen:                    seen.add((r, c))                    shape.append(di)                    explore(r+1,c,1)                    explore(r-1,c,2)                    explore(r,c+1,3)                    explore(r,c-1,4)                            shapes = set()        for r in range(len(grid)):            for c in range(len(grid[0])):                shape = []                explore(r, c)                if shape:                    shapes.add(tuple(shape))        return len(shapes)        def numDistinctIslands(self, grid: List[List[int]]) -> int:        # seen = set()        def explore(r, c, di = 0):            if 0 <= r < len(grid) and 0 <= c < len(grid[0]) and \                grid[r][c]:                    grid[r][c] = 0                    shape.append(di)                    explore(r+1,c,1)                    shape.append(di)                    explore(r-1,c,2)                    shape.append(di)                    explore(r,c+1,3)                    shape.append(di)                    explore(r,c-1,4)                    shape.append(di)                            shapes = set()        for r in range(len(grid)):            for c in range(len(grid[0])):                if grid[r][c] == 1:                    shape = []                    explore(r, c)                    if shape:                        shapes.add(tuple(shape))        # print (shapes)        return len(shapes)    sol = Solution()print (sol.numDistinctIslands1([[1,1,0,1,1],[1,0,0,0,0],[0,0,0,0,1],[1,1,0,1,1]]))