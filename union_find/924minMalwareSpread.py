'''
keys: 
Solutions:
Similar: 
T:
S:
'''
from typing import List
from collections import Counter


class DSU:

	def __init__(self, N):
		self.p = list(range(N)) # N as number of nodes
		self.rank = [1] * N
		self.sz = [1] * N

	def find(self, x):
		if self.p[x] != x:
			self.p[x] = self.find(self.p[x])
		return self.p[x]

	def union(self, a, b): # union by rank
		ra, rb = self.find(a), self.find(b)
		if ra == rb:
			return
		if self.rank[ra] < self.rank[rb]:
			self.p[ra] = rb # for these steps we dont increase rank since we move lower rank to high rank component
			self.sz[rb] += self.sz[ra]
		elif self.rank[ra] > self.rank[rb]:
			self.p[rb] = ra
			self.sz[ra] += self.sz[rb]
		else:
			self.p[rb] = ra
			self.sz[ra] += self.sz[rb]
			self.rank[ra] += 1 # ra rank increases

	def size(self, x):
		return self.sz[self.find(x)]

class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
    	dsu = DSU(len(graph))
    	for rIdx, row in enumerate(graph):
    		for j in range(rIdx):
    			if row[j]:
    				dsu.union(rIdx, j)

    	ct = Counter(dsu.find(node) for node in initial)
    	res = (-1, min(initial))
    	for node in initial: 
    		root = dsu.find(node)
    		# we only consider those unique nodes, if not unique, removing it is uselss
    		# since it will be spread by other nodes in the component
    		if ct[root] == 1: 
    			if dsu.size(root) > res[0]: # larger component size
    				res = (dsu.size(root), node)
    			elif dsu.size(root) == res[0] and node < res[1]: # smaller index 
    				res = (res[0], node)
    	return res[1]





   	# dfs version
   	# T: O(N^2) since nodes number is N^2, acutally faster than DSU
   	def minMalwareSpread(self, graph, initial):
        # 1. Color each component.
        # colors[node] = the color of this node.

        N = len(graph)
        colors = {}
        c = 0

        def dfs(node, color):
            colors[node] = color
            for nei, adj in enumerate(graph[node]):
                if adj and nei not in colors:
                    dfs(nei, color)

        for node in xrange(N):
            if node not in colors:
                dfs(node, c)
                c += 1

        # 2. Size of each color.
        # size[color] = number of occurrences of this color.
        size = collections.Counter(colors.values())

        # 3. Find unique colors.
        color_count = collections.Counter()
        for node in initial:
            color_count[colors[node]] += 1

        # 4. Answer
        ans = float('inf')
        for x in initial:
            c = colors[x]
            if color_count[c] == 1:
                if ans == float('inf'):
                    ans = x
                elif size[c] > size[colors[ans]]:
                    ans = x
                elif size[c] == size[colors[ans]] and x < ans:
                    ans = x

        return ans if ans < float('inf') else min(initial)    