'''keys: Solutions:Similar: T:S:'''from typing import List# Definition for a binary tree node.class TreeNode:    def __init__(self, x):        self.val = x        self.left = None        self.right = Noneclass Solution:    # smart one; T: O(H_p), H_p as the height of node p; S: O(1)    def inorderSuccessor1(self, root: 'TreeNode', p: 'TreeNode') -> 'TreeNode':        candidate = None        cur = root         while cur:            # If current node's value is greater than p's value, current node             # is a candidate. Go to its left subtree to see if we can find a             # smaller one (but still larger than p.val).            if p.val < cur.val: # smaller, go left, cur become candidate                candidate = cur                cur = cur.left            else: # p.val >= cur.val                # If current node's value is less than or equal to p's value,                # we know our answer must be in the right subtree.                cur = cur.right        return candidate            # not intuitive recursion one    def inorderSuccessor2(self, root: 'TreeNode', p: 'TreeNode') -> 'TreeNode':        if not root: return None        if root.val <= p.val:            return self.inorderSuccessor2(root.right, p)        else:            left = self.inorderSuccessor2(root.left, p)            return left if left else root                        # T: O(H_p), height of node p    # S: O(1) in best case or O(H) to keep the stack    # https://leetcode.com/problems/inorder-successor-in-bst/solution/    def inorderSuccessor(self, root: 'TreeNode', p: 'TreeNode') -> 'TreeNode':        # the successor is somewhere lower in the right subtree        # successor: one step right and then left till you can        if p.right:            p = p.right            while p.left:                p = p.left            return p                # the successor is somewhere upper in the tree        stack, inorder = [], float('-inf')                # inorder traversal : left -> node -> right        while stack or root:            # 1. go left till you can            while root:                stack.append(root)                root = root.left                            # 2. all logic around the node            root = stack.pop()            if inorder == p.val:    # if the previous node was equal to p                return root         # then the current node is its successor            inorder = root.val                        # 3. go one step right            root = root.right        # there is no successor        return None        