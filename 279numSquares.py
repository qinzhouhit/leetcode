'''keys: Solutions:Similar:T:S:'''from typing import Listimport mathclass Solution:    # mathematics    # T: O(sqrt(n)); S: O(1)    def isSquare(self, n: int) -> bool:        sq = int(math.sqrt(n))        return sq*sq == n        def numSquares4(self, n: int) -> int:        # four-square and three-square theorems        while (n & 3) == 0:            n >>= 2      # reducing the 4^k factor from number        if (n & 7) == 7: # mod 8            return 4        if self.isSquare(n):            return 1        # check if the number can be decomposed into sum of two squares        for i in range(1, int(n**(0.5)) + 1):            if self.isSquare(n - i*i):                return 2        # bottom case from the three-square theorem        return 3            # greedy + BFS; using n-ary concept    # O(n^(h/2)),h as the max number of recursion    # S: O(sqrt(n)^h), for square_nums    def numSquares3(self, n: int) -> int:        square_nums = [i**2 for i in range(1, int(math.sqrt(n)) + 1)]        level = 0        queue = {n}        while queue:            level += 1            #! Important: use set() instead of list() to eliminate the redundancy,            # which would even provide a 5-times speedup, 200ms vs. 1000ms.            next_queue = set()            # construct the queue for the next level            for remainder in queue:                for square_num in square_nums:                        if remainder == square_num:                        return level  # find the node!                    elif remainder < square_num:                        break                    else:                        next_queue.add(remainder - square_num)            queue = next_queue        return level                # greedy enumeration    # O(n^(h/2)),h as the max number of recursion    # S: O(sqrt(n)), for square_nums    def numSquares2(self, n: int) -> int:        square_nums = [i**2 for i in range(1, int(math.sqrt(n)) + 1)]                def is_divided(n, ct):            if ct == 1:                return n in square_nums            for k in square_nums:                if is_divided(n - k, ct - 1):                    return True            return False                for ct in range(1, n+1):            if is_divided(n, ct):                return ct            # dp[n] as the result of numSquares(n)    # T: O(n*sqrt(n)), sqrt(n) for the size of square nums    # S: O(n) for dp    def numSquares1(self, n: int) -> int:        dp = [float("inf")] * (n+1)        square_nums = [i**2 for i in range(1, int(math.sqrt(n)) + 1)]                dp[0] = 0        for i in range(1, n+1):            for square in square_nums:                if i < square:                    break                dp[i] = min(dp[i], dp[i-square]+1)        return dp[-1]                        # brute-force enumeration for the combination    # recursively    def numSquares(self, n: int) -> int:        nums = [i**2 for i in range(1, int(math.sqrt(n)) + 1)]                def helper(k):            # minNumSquare            if k in nums:                return 1            min_num = float("inf")            # find all possible solutions            for square in nums:                if k < square:                    break                new_num = helper(k - square) + 1                min_num = min(min_num, new_num)            return min_num                    return helper(n)                