'''keys: Solutions:Similar: 518T:S:'''from typing import Listclass Solution:    # space optimize    # T: O(len(nums) * sum(nums))    def canPartition1(self, nums: List[int]) -> bool:        sum_ = sum(nums)                # odd, then impossible to split        # if (sum_ & 1) == 1: return False        if sum_ % 2: return False                sum_ //= 2        dp = [False] * (sum_ + 1)                     dp[0] = True                for num in nums:            for i in range(sum_, 0, -1):                if i >= num:                    dp[i] = dp[i] or dp[i-num]        # print (dp)        return dp[-1]                        '''    Let us assume dp[i][j] means whether the specific sum j can be gotten     from the first i numbers. If we can pick such a series of numbers from     0-i whose sum is j, dp[i][j] is true, otherwise it is false.    '''    def canPartition(self, nums: List[int]) -> bool:        sum_ = sum(nums)                # odd, then impossible to split        # if (sum_ & 1) == 1: return False        if sum_ % 2: return False                sum_ //= 2        dp = [[False] * (sum_ + 1) for _ in range(len(nums))]                for i in range(1, len(nums)):            dp[i][0] = True                for j in range(1, sum_ + 1):            dp[0][j] = False                    dp[0][0] = True                for i in range(1, len(nums)):            for j in range(1, sum_ + 1):                dp[i][j] = dp[i-1][j]                if j >= nums[i-1]:                    dp[i][j] = dp[i][j] or dp[i-1][j-nums[i-1]]        # print (dp)        return dp[len(nums)-1][sum_]                        