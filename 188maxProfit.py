'''keys: DPSolutions:Similar:T:S:'''from typing import Listclass Solution:    # dp[i][j] = maximum profit from at most i transactions using prices[0..j]    def maxProfit(self, k: int, prices: List[int]) -> int:        n = len(prices)        # special case        if not prices or k == 0:            return 0        if 2*k > n: # daily trade            res = 0            for i, j in zip(prices[:-1], prices[1:]):                res += max(0, j - i)            return res        # general case        dp = [[[0] for _ in range(n)] for _ in range(k + 1)]        for i in range(1, k+1):            tmpMax = -prices[0]            for j in range(1, n):                # hold the stock: dp[i][j-1]; sell the stock: tmpMax + prices[j]                dp[i][j] = max(dp[i][j-1], prices[j] + tmpMax)                # tmpMax means the maximum profit of just doing at most i-1                 # transactions, using at most first j-1 prices, and buying                 # the stock at price[j] - this is used for the next loop.                tmpMax =  max(tmpMax, dp[i - 1][j - 1] - prices[j])        return dp[k][n - 1]                                def maxProfit(self, k: int, prices: List[int]) -> int:        '''        The value of dp[i][j][l] represents the best profit we can have at the        end of the i-th day, with j remaining transactions to make and l stocks.        one transaction: 1 buy + 1 sell        '''        n = len(prices)        # special case        if not prices or k == 0:            return 0        if 2*k > n:            res = 0            for i, j in zip(prices[:-1], prices[1:]):                res += max(0, j - i)            return res        # general case        # dp[i][used_k][ishold] = balance        # ishold: 0 nothold, 1 hold        dp = [[[-float("inf")] for _ in range(k+1)] for _ in range(n)]                # set starting value        dp[0][0][0] = 0        dp[0][1][1] = -prices[0]                for i in range(1, n):            for j in range(k+1):                # transition: keep not holding or selling                dp[i][j][0] = max(dp[i-1][j][0], dp[i-1][j][1] + prices[i])                # keep holding or buying, but you need at least 1 transaction                if j > 0:                    dp[i][j][1] = max(dp[i-1][j][1], dp[i-1][j-1][0] - prices[i])        res = max(dp[-1][j][0] for j in range(k+1))        return res