'''keys: Solutions:Similar: T:S:'''from typing import Listfrom collections import deque# Definition for a binary tree node.class TreeNode:    def __init__(self, val=0, left=None, right=None):        self.val = val        self.left = left        self.right = right        class Solution:    # Optimized Iterative BFS Traversal.    # O(N) for S and T    def deepestLeavesSum3(self, root: TreeNode) -> int:        next_level = deque([root,])                while next_level:            # prepare for the next level            curr_level = next_level            next_level = deque()                        for node in curr_level:                # add child nodes of the current level                # in the queue for the next level                if node.left:                    next_level.append(node.left)                if node.right:                    next_level.append(node.right)                return sum([node.val for node in curr_level])        # Iterative BFS Traversal    # O(N) for S and T    def deepestLeavesSum2(self, root: TreeNode) -> int:        deepest_sum = depth = 0        queue = deque([(root, 0),])        while queue:            node, curr_depth = queue.popleft()            if node.left is None and node.right is None:                # if this leaf is the deepest one seen so far                if depth < curr_depth:                    deepest_sum = node.val      # start new sum                    depth = curr_depth          # note new depth                # if there were already leaves at this depth                elif depth == curr_depth:                    deepest_sum += node.val     # update existing sum                else:                if node.left:                    queue.append((node.left, curr_depth + 1))                if node.right:                    queue.append((node.right, curr_depth + 1))                                return deepest_sum            # Iterative DFS Preorder Traversal    # O(N) for T and O(H) for S    def deepestLeavesSum1(self, root: TreeNode) -> int:        deepest_sum = depth = 0        stack = [(root, 0) ]                while stack:            node, curr_depth = stack.pop()            if node.left is None and node.right is None:                # if this leaf is the deepest one seen so far                if depth < curr_depth:                    deepest_sum = node.val      # start new sum                    depth = curr_depth          # note new depth                # if there were already leaves at this depth                elif depth == curr_depth:                    deepest_sum += node.val     # update existing sum                                else:                if node.right:                    stack.append((node.right, curr_depth + 1))                if node.left:                    stack.append((node.left, curr_depth + 1))                                return deepest_sum            # self made    def deepestLeavesSum(self, root: TreeNode) -> int:        if not root:            return 0                stack = [(root, 0)]        rec = collections.defaultdict(list)        res = 0        while stack:            node, level = stack.pop()            if node:                rec[level].append(node.val)                level += 1                stack.append((node.left, level))                stack.append((node.right, level))        key_ = max(rec.keys())        print (key_, rec[key_])        return sum(rec[key_])            