'''keys: Solutions:Similar: T:S:'''from typing import Listclass Solution:    # in-place    def gameOfLife1(self, board: List[List[int]]) -> None:        """        Do not return anything, modify board in-place instead.        """        # Neighbors array to find 8 neighboring cells for a given cell        neighbors = [(1,0), (1,-1), (0,-1), (-1,-1), (-1,0), (-1,1), (0,1), (1,1)]        rows = len(board)        cols = len(board[0])        # Iterate through board cell by cell.        for row in range(rows):            for col in range(cols):                # For each cell count the number of live neighbors.                live_neighbors = 0                for neighbor in neighbors:                    # row and column of the neighboring cell                    r = (row + neighbor[0])                    c = (col + neighbor[1])                    # Check the validity of the neighboring cell and if it was originally a live cell.                    if (0 <= r < rows) and (0 <= c < cols) and abs(board[r][c]) == 1:                        live_neighbors += 1                # Rule 1 or Rule 3                if board[row][col] == 1 and (live_neighbors < 2 or live_neighbors > 3):                    # -1 signifies the cell is now dead but originally was live.                    board[row][col] = -1                # Rule 4                if board[row][col] == 0 and live_neighbors == 3:                    # 2 signifies the cell is now live but was originally dead.                    board[row][col] = 2        # Get the final representation for the newly updated board.        for row in range(rows):            for col in range(cols):                if board[row][col] > 0: # 1 or 2                    board[row][col] = 1                else: # now dead                    board[row][col] = 0                                                                    # O(M*N) for S and T    def gameOfLife(self, board: List[List[int]]) -> None:        """        Do not return anything, modify board in-place instead.        """        # Neighbors array to find 8 neighboring cells for a given cell        neighbors = [(1,0), (1,-1), (0,-1), (-1,-1), (-1,0), (-1,1), (0,1), (1,1)]        rows = len(board)        cols = len(board[0])                # Create a copy of the original board        copy_board = [[board[row][col] for col in range(cols)] for row in range(rows)]                # Iterate through board cell by cell.        for row in range(rows):            for col in range(cols):                                # For each cell count the number of live neighbors.                live_neighbors = 0                for neighbor in neighbors:                    r = (row + neighbor[0])                    c = (col + neighbor[1])                                        # Check the validity of the neighboring cell and if it was originally a live cell.                    # The evaluation is done against the copy, since that is never updated.                    if (0 <= r < rows) and (0 <= c < cols) and (copy_board[r][c] == 1):                        live_neighbors += 1                                    # Rule 1 or Rule 3                        if copy_board[row][col] == 1 and (live_neighbors < 2 or live_neighbors > 3):                    board[row][col] = 0                # Rule 4                if copy_board[row][col] == 0 and live_neighbors == 3:                    board[row][col] = 1