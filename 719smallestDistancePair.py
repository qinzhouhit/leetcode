'''keys: Solutions:Similar: T:S:'''from typing import Listimport heapqclass Solution:    # T: O(NlogN + MlogN), T: O(NlogN) for the initial sort of nums     # possible() does 2N passes, i.e., O(N), and we call it logM times, where     # M as the max distance possible, i.e. max num - min num. Thus O(N * lg M)    def smallestDistancePair2(nums, k):        # Return: Is there k or more pairs with distance <= guess? i.e. are        # there enough?        def possible(guess_dist):            i = count = 0            j = 1            # Notice that we never decrement j or i.            while i < len(nums):                # If the distance calculated from j-i is less than the guess,                # increase the window on `j` side.                while (j < len(nums)) and ((nums[j] - nums[i]) <= guess_dist):                    j += 1                # Count all places between j and i                count += j - i - 1                i += 1            return count >= k # at least k pairs <= guess_dist            nums.sort()        lo = 0        hi = nums[-1] - nums[0]            while lo < hi:            mid = (lo + hi) // 2            # If `mid` produced `k` or more results we know it's the upper bound.            if possible(mid):                # We don't set to `mid - 1` because we found a number of                 # distances bigger than *or equal* to `k`. If this `mid` ends up                 # being actually equal to `k` then it's a correct guess, so                 # llet's  eave it within the guess space.                hi = mid            # If `mid` did not produce enouh results, let's increase the guess            # space and try a higher number.            else:                lo = mid + 1            # `lo` ends up being an actual distance in the input, because        # the binary search mechanism waits until the exact lo/hi combo where        # 2nd to last `mid` did not produce enough results (k or more), but        # the last `mid` did.        return lo                # TLE; T: O((K+N)logN), N as the length of nums    def smallestDistancePair1(self, nums: List[int], k: int) -> int:        nums.sort()        heap = [(nums[i+1] - nums[i], i, i+1)                for i in range(len(nums) - 1)]        heapq.heapify(heap)        for _ in range(k):            d, root, nei = heapq.heappop(heap)            if nei + 1 < len(nums):                # use the pair (i, x), add (i, x+1)                heapq.heappush(heap, (nums[nei + 1] - nums[root], \                                      root, nei + 1))        return d        # TLE    def smallestDistancePair(self, nums: List[int], k: int) -> int:        diffs = []        for i in range(len(nums)):            for j in range(i+1, len(nums)):                diffs.append(abs(nums[i]-nums[j]))        diffs.sort()        return diffs[k-1]    sol = Solution()print (sol.smallestDistancePair1([1,2,5,8,3,2,5,53], 3))